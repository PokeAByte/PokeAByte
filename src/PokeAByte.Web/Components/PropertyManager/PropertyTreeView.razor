@using PokeAByte.Web.Models
@using PokeAByte.Web.Services.Properties
@implements IDisposable
<MudTreeView Items="@Context"
             Color="Color.Default"
             Dense="true"
             Hover="true"
             ExpandOnClick="false"
             Ripple="false"
             SelectedValueChanged="OnSelectedValueHasChanged">
    <ItemTemplate>
        @{
            var presenter = context as PropertyTreePresenter ?? throw new InvalidOperationException();
        }
        <MudTreeViewItem Items="@(presenter.Children?
                                    .Where(x => x.Value?.CurrentCount <= _maxCount)
                                    .ToList())"
                         OnClick="() => OnTreeItemClick(presenter)"
                         Expanded="@presenter.Expanded"
                         Value="@presenter.Value"
                         Text="@presenter.Text"
                         Disabled="@presenter.IsDisabled"
                         Style="background-color:var(--mud-palette-background); margin-top: 2px; margin-bottom: 2px"
                         Class="mud-elevation-0 px-4 ml-2 rounded-lg">
            <Content>
                @if (presenter.HasChildren)
                {
                    <MudIcon Icon="@SetIcon(presenter)"
                             Class="pr-2"/>
                    <MudText Typo="Typo.body2" Class="py-1" Style="width:15px">@presenter.Text</MudText>
                    <MudText Typo="Typo.body2" Class="py-1" Style="@($"width:{GetWidth(presenter, GetAdditionalInfo(context))}px;")">
                        @GetAdditionalInfo(presenter)
                    </MudText>
                    <MudText Typo="Typo.body2" Class="py-1" Style="color:#616161">@context.Children?.Count Entries</MudText>
                }
                else if (presenter is { IsDisabled: false, Value: not null } &&
                     presenter.Value.CurrentCount + 1 <= _maxCount)
                {
                    <PropertyValueViewer Context="@presenter" Parent="@this"/>
                }
                else if (presenter is { IsDisabled: false, Value.PropertyModel: not null } &&
                         presenter.Value.CurrentCount == _maxCount)
                {
                <MudLink OnClick="() => OnClickLoadEntries(presenter)"
                         Color="Color.Success">
                    Click here to load more entries.
                </MudLink>
                }
            </Content>
        </MudTreeViewItem>
    </ItemTemplate>
</MudTreeView>
@code {
    [Inject] public required PropertyService PropertyService { get; set; }
    [Parameter] public required IReadOnlyList<TreeItemData<PropertyTreeItem>> Context { get; set; }
    public Action<PropertyTreeItem?>? OnSelectedValueHasChanged { get; set; }

    private const int CountIncrease = 150;
    private int _maxCount = CountIncrease;

    protected override void OnAfterRender(bool firstRender)
    {
        if (firstRender)
        {
            OnSelectedValueHasChanged += SelectedValueHasChangedHandler;
        }
        base.OnAfterRender(firstRender);
    }

    private PropertyTreeItem? _previous;
    private void SelectedValueHasChangedHandler(PropertyTreeItem? ctx)
    {
        if (_previous?.PropertyModel is not null)
        {
            _previous.PropertyModel.ValueString = _previous?.PropertyModel?.Value?.ToString() ?? "";
            if (_previous?.PropertyModel is not null) _previous.PropertyModel.IsEditing = false;
        }
        if (ctx?.PropertyModel is not null)
            ctx.PropertyModel.IsEditing = true;
        
        _previous = ctx;
    }

    private string SetIcon(TreeItemData<PropertyTreeItem> context)
    {        
        return context.HasChildren
            ? (context.Expanded ? Icons.Material.Filled.FolderOpen : Icons.Material.Filled.Folder)
            : Icons.Material.Filled.Folder;
    }

    private string GetAdditionalInfo(TreeItemData<PropertyTreeItem> context)
    {
        var intConvert = int.TryParse(context.Text, out var result);
        if (!intConvert) return "";
        var firstChild =
            (context.HasChildren ? 
                context.Children?.FirstOrDefault(x => x.Value?.Name is "species") : 
                null) ?? (context.HasChildren ? 
                context.Children?.First() : 
                null);
        if (firstChild?.Value?.PropertyModel == null) return "";
        return string.IsNullOrWhiteSpace(firstChild.Value.PropertyModel.Value?.ToString()) ? "" : $" ({firstChild.Value.PropertyModel.Value})";
    }

    private string GetWidth(PropertyTreePresenter presenter, string additionalInfo)
    {
        List<TreeItemData<PropertyTreeItem>>? children;
        //Get the parent
        if (presenter.Parent is not null)
        {
            children = presenter.Parent.Children;
        }
        else
        {
            //This is the root nodes just get a list of root nodes
            children = PropertyService
                .PropertyTree
                .Where(x => x.HasChildren)
                .ToList();
        }
        //Failed to find children just make the length the size of the entry (8*16 ~= 125 px)
        if (children is null) return (presenter.Text?.Length ?? 16 * 8).ToString();
        //Iterate through the children and get the largest text size
        var length = children
            .Aggregate(0, (max, current) =>
                Math.Max(max, current.Text?.Length ?? 16)) * 10;
        if (length < 75) length = 75;
        if (!string.IsNullOrWhiteSpace(additionalInfo))
        {
            length += additionalInfo.Length * 10;
        }
        return length.ToString();
    }

    private void OnClickLoadEntries(PropertyTreePresenter presenter)
    {
        _maxCount += CountIncrease;
        if (presenter.Children is not null && presenter.HasChildren)
        {
            foreach (var child in presenter
                         .Children
                         .Where(x => x.Value?.CurrentCount <= _maxCount))
            {
                if (child is not PropertyTreePresenter childPresenter)
                    continue;
                childPresenter.IsDisabled = !childPresenter.Expanded;
            }
        }
        StateHasChanged();
    }

    private void OnTreeItemClick(PropertyTreePresenter context)
    {
        if(!context.Expandable || !context.HasChildren)
            return;
        context.Expanded = !context.Expanded;
        //context.IsDisabled = !context.Expanded;
        foreach (var child in context.Children!)
        {
            if (child is PropertyTreePresenter presenter)
            {
                presenter.IsDisabled = !context.Expanded;
            }
        }
        PropertyService.SaveOpenProperty(context);
    }

    public Action? Refresh;

    public void AttachRefreshEvent(Action? refreshEvent)
    {
        Refresh += refreshEvent;
    }
    public void DetachRefreshEvent(Action? refreshEvent)
    {
        Refresh -= refreshEvent;
    }
    public void RefreshChildren()
    {
        //StateHasChanged();
        Refresh?.Invoke();
    }

    public void Dispose()
    {
        OnSelectedValueHasChanged -= SelectedValueHasChangedHandler;
    }

}