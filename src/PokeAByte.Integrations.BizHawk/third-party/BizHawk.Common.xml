<?xml version="1.0"?>
<doc>
    <assembly>
        <name>BizHawk.Common</name>
    </assembly>
    <members>
        <member name="T:System.Diagnostics.CodeAnalysis.ExperimentalAttribute">
            <summary>
            Indicates that an API is experimental and it may change in the future.
            </summary>
            <remarks>
            This attribute allows call sites to be flagged with a diagnostic that indicates that an experimental
            feature is used. Authors can use this attribute to ship preview features in their assemblies.
            </remarks>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.ExperimentalAttribute.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:System.Diagnostics.CodeAnalysis.ExperimentalAttribute"/> class,
            specifying the ID that the compiler will use when reporting a use of the API the attribute applies to.
            </summary>
            <param name="diagnosticId">The ID that the compiler will use when reporting a use of the API the attribute applies to.</param>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.ExperimentalAttribute.DiagnosticId">
            <summary>
            Gets the ID that the compiler will use when reporting a use of the API the attribute applies to.
            </summary>
            <value>The unique diagnostic ID.</value>
            <remarks>
            The diagnostic ID is shown in build output for warnings and errors.
            <para>This property represents the unique ID that can be used to suppress the warnings or errors, if needed.</para>
            </remarks>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.ExperimentalAttribute.UrlFormat">
            <summary>
            Gets or sets the URL for corresponding documentation.
            The API accepts a format string instead of an actual URL, creating a generic URL that includes the diagnostic ID.
            </summary>
            <value>The format string that represents a URL to corresponding documentation.</value>
            <remarks>An example format string is <c>https://contoso.com/obsoletion-warnings/{0}</c>.</remarks>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.SetsRequiredMembersAttribute">
            <summary>
            Specifies that this constructor sets all required members for the current type,
            and callers do not need to set any required members themselves.
            </summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.StringSyntaxAttribute">
            <summary>
            Specifies the syntax used in a string.
            </summary>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.StringSyntaxAttribute.#ctor(System.String)">
            <summary>
            Initializes the <see cref="T:System.Diagnostics.CodeAnalysis.StringSyntaxAttribute"/> with the identifier of the syntax used.
            </summary>
            <param name="syntax">The syntax identifier.</param>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.StringSyntaxAttribute.#ctor(System.String,System.Object[])">
            <summary>Initializes the <see cref="T:System.Diagnostics.CodeAnalysis.StringSyntaxAttribute"/> with the identifier of the syntax used.</summary>
            <param name="syntax">The syntax identifier.</param>
            <param name="arguments">Optional arguments associated with the specific syntax employed.</param>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.StringSyntaxAttribute.Syntax">
            <summary>Gets the identifier of the syntax used.</summary>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.StringSyntaxAttribute.Arguments">
            <summary>Optional arguments associated with the specific syntax employed.</summary>
        </member>
        <member name="F:System.Diagnostics.CodeAnalysis.StringSyntaxAttribute.CompositeFormat">
            <summary>The syntax identifier for strings containing composite formats for string formatting.</summary>
        </member>
        <member name="F:System.Diagnostics.CodeAnalysis.StringSyntaxAttribute.DateOnlyFormat">
            <summary>The syntax identifier for strings containing date format specifiers.</summary>
        </member>
        <member name="F:System.Diagnostics.CodeAnalysis.StringSyntaxAttribute.DateTimeFormat">
            <summary>The syntax identifier for strings containing date and time format specifiers.</summary>
        </member>
        <member name="F:System.Diagnostics.CodeAnalysis.StringSyntaxAttribute.EnumFormat">
            <summary>The syntax identifier for strings containing <see cref="T:System.Enum"/> format specifiers.</summary>
        </member>
        <member name="F:System.Diagnostics.CodeAnalysis.StringSyntaxAttribute.GuidFormat">
            <summary>The syntax identifier for strings containing <see cref="T:System.Guid"/> format specifiers.</summary>
        </member>
        <member name="F:System.Diagnostics.CodeAnalysis.StringSyntaxAttribute.Json">
            <summary>The syntax identifier for strings containing JavaScript Object Notation (JSON).</summary>
        </member>
        <member name="F:System.Diagnostics.CodeAnalysis.StringSyntaxAttribute.NumericFormat">
            <summary>The syntax identifier for strings containing numeric format specifiers.</summary>
        </member>
        <member name="F:System.Diagnostics.CodeAnalysis.StringSyntaxAttribute.Regex">
            <summary>The syntax identifier for strings containing regular expressions.</summary>
        </member>
        <member name="F:System.Diagnostics.CodeAnalysis.StringSyntaxAttribute.TimeOnlyFormat">
            <summary>The syntax identifier for strings containing time format specifiers.</summary>
        </member>
        <member name="F:System.Diagnostics.CodeAnalysis.StringSyntaxAttribute.TimeSpanFormat">
            <summary>The syntax identifier for strings containing <see cref="T:System.TimeSpan"/> format specifiers.</summary>
        </member>
        <member name="F:System.Diagnostics.CodeAnalysis.StringSyntaxAttribute.Uri">
            <summary>The syntax identifier for strings containing URIs.</summary>
        </member>
        <member name="F:System.Diagnostics.CodeAnalysis.StringSyntaxAttribute.Xml">
            <summary>The syntax identifier for strings containing XML.</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.UnscopedRefAttribute">
            <summary>
            Used to indicate a byref escapes and is not scoped.
            </summary>
            <remarks>
            <para>
            There are several cases where the C# compiler treats a <see langword="ref"/> as implicitly
            <see langword="scoped"/> - where the compiler does not allow the <see langword="ref"/> to escape the method.
            </para>
            <para>
            For example:
            <list type="number">
                <item><see langword="this"/> for <see langword="struct"/> instance methods.</item>
                <item><see langword="ref"/> parameters that refer to <see langword="ref"/> <see langword="struct"/> types.</item>
                <item><see langword="out"/> parameters.</item>
            </list>
            </para>
            <para>
            This attribute is used in those instances where the <see langword="ref"/> should be allowed to escape.
            </para>
            <para>
            Applying this attribute, in any form, has impact on consumers of the applicable API. It is necessary for
            API authors to understand the lifetime implications of applying this attribute and how it may impact their users.
            </para>
            </remarks>
        </member>
        <member name="T:System.Index">
            <summary>Represent a type can be used to index a collection either from the start or the end.</summary>
            <remarks>
            Index is used by the C# compiler to support the new index syntax
            <code>
            int[] someArray = new int[5] { 1, 2, 3, 4, 5 } ;
            int lastElement = someArray[^1]; // lastElement = 5
            </code>
            </remarks>
        </member>
        <member name="M:System.Index.#ctor(System.Int32,System.Boolean)">
            <summary>Construct an Index using a value and indicating if the index is from the start or from the end.</summary>
            <param name="value">The index value. it has to be zero or positive number.</param>
            <param name="fromEnd">Indicating if the index is from the start or from the end.</param>
            <remarks>
            If the Index constructed from the end, index value 1 means pointing at the last element and index value 0 means pointing at beyond last element.
            </remarks>
        </member>
        <member name="P:System.Index.Start">
            <summary>Create an Index pointing at first element.</summary>
        </member>
        <member name="P:System.Index.End">
            <summary>Create an Index pointing at beyond last element.</summary>
        </member>
        <member name="M:System.Index.FromStart(System.Int32)">
            <summary>Create an Index from the start at the position indicated by the value.</summary>
            <param name="value">The index value from the start.</param>
        </member>
        <member name="M:System.Index.FromEnd(System.Int32)">
            <summary>Create an Index from the end at the position indicated by the value.</summary>
            <param name="value">The index value from the end.</param>
        </member>
        <member name="P:System.Index.Value">
            <summary>Returns the index value.</summary>
        </member>
        <member name="P:System.Index.IsFromEnd">
            <summary>Indicates whether the index is from the start or the end.</summary>
        </member>
        <member name="M:System.Index.GetOffset(System.Int32)">
            <summary>Calculate the offset from the start using the giving collection length.</summary>
            <param name="length">The length of the collection that the Index will be used with. length has to be a positive value</param>
            <remarks>
            For performance reason, we don't validate the input length parameter and the returned offset value against negative values.
            we don't validate either the returned offset is greater than the input length.
            It is expected Index will be used with collections which always have non negative length/count. If the returned offset is negative and
            then used to index a collection will get out of range exception which will be same affect as the validation.
            </remarks>
        </member>
        <member name="M:System.Index.Equals(System.Object)">
            <summary>Indicates whether the current Index object is equal to another object of the same type.</summary>
            <param name="value">An object to compare with this object</param>
        </member>
        <member name="M:System.Index.Equals(System.Index)">
            <summary>Indicates whether the current Index object is equal to another Index object.</summary>
            <param name="other">An object to compare with this object</param>
        </member>
        <member name="M:System.Index.GetHashCode">
            <summary>Returns the hash code for this instance.</summary>
        </member>
        <member name="M:System.Index.op_Implicit(System.Int32)~System.Index">
            <summary>Converts integer number to an Index.</summary>
        </member>
        <member name="M:System.Index.ToString">
            <summary>Converts the value of the current Index object to its equivalent string representation.</summary>
        </member>
        <member name="T:System.Range">
            <summary>Represent a range has start and end indexes.</summary>
            <remarks>
            Range is used by the C# compiler to support the range syntax.
            <code>
            int[] someArray = new int[5] { 1, 2, 3, 4, 5 };
            int[] subArray1 = someArray[0..2]; // { 1, 2 }
            int[] subArray2 = someArray[1..^0]; // { 2, 3, 4, 5 }
            </code>
            </remarks>
        </member>
        <member name="P:System.Range.Start">
            <summary>Represent the inclusive start index of the Range.</summary>
        </member>
        <member name="P:System.Range.End">
            <summary>Represent the exclusive end index of the Range.</summary>
        </member>
        <member name="M:System.Range.#ctor(System.Index,System.Index)">
            <summary>Construct a Range object using the start and end indexes.</summary>
            <param name="start">Represent the inclusive start index of the range.</param>
            <param name="end">Represent the exclusive end index of the range.</param>
        </member>
        <member name="M:System.Range.Equals(System.Object)">
            <summary>Indicates whether the current Range object is equal to another object of the same type.</summary>
            <param name="value">An object to compare with this object</param>
        </member>
        <member name="M:System.Range.Equals(System.Range)">
            <summary>Indicates whether the current Range object is equal to another Range object.</summary>
            <param name="other">An object to compare with this object</param>
        </member>
        <member name="M:System.Range.GetHashCode">
            <summary>Returns the hash code for this instance.</summary>
        </member>
        <member name="M:System.Range.ToString">
            <summary>Converts the value of the current Range object to its equivalent string representation.</summary>
        </member>
        <member name="M:System.Range.StartAt(System.Index)">
            <summary>Create a Range object starting from start index to the end of the collection.</summary>
        </member>
        <member name="M:System.Range.EndAt(System.Index)">
            <summary>Create a Range object starting from first element in the collection to the end Index.</summary>
        </member>
        <member name="P:System.Range.All">
            <summary>Create a Range object starting from first element to the end.</summary>
        </member>
        <member name="M:System.Range.GetOffsetAndLength(System.Int32)">
            <summary>Calculate the start offset and length of range object using a collection length.</summary>
            <param name="length">The length of the collection that the range will be used with. length has to be a positive value.</param>
            <remarks>
            For performance reason, we don't validate the input length parameter against negative values.
            It is expected Range will be used with collections which always have non negative length/count.
            We validate the range is inside the length scope though.
            </remarks>
        </member>
        <member name="T:System.Runtime.CompilerServices.AsyncMethodBuilderAttribute">
            <summary>
            Indicates the type of the async method builder that should be used by a language compiler to
            build the attributed async method or to build the attributed type when used as the return type
            of an async method.
            </summary>
        </member>
        <member name="M:System.Runtime.CompilerServices.AsyncMethodBuilderAttribute.#ctor(System.Type)">
            <summary>Initializes the <see cref="T:System.Runtime.CompilerServices.AsyncMethodBuilderAttribute"/>.</summary>
            <param name="builderType">The <see cref="T:System.Type"/> of the associated builder.</param>
        </member>
        <member name="P:System.Runtime.CompilerServices.AsyncMethodBuilderAttribute.BuilderType">
            <summary>Gets the <see cref="T:System.Type"/> of the associated builder.</summary>
        </member>
        <member name="T:System.Runtime.CompilerServices.CallerArgumentExpressionAttribute">
            <summary>
            An attribute that allows parameters to receive the expression of other parameters.
            </summary>
        </member>
        <member name="M:System.Runtime.CompilerServices.CallerArgumentExpressionAttribute.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:System.Runtime.CompilerServices.CallerArgumentExpressionAttribute"/> class.
            </summary>
            <param name="parameterName">The condition parameter value.</param>
        </member>
        <member name="P:System.Runtime.CompilerServices.CallerArgumentExpressionAttribute.ParameterName">
            <summary>
            Gets the parameter name the expression is retrieved from.
            </summary>
        </member>
        <member name="M:System.Runtime.CompilerServices.CollectionBuilderAttribute.#ctor(System.Type,System.String)">
            <summary>
            Initialize the attribute to refer to the <paramref name="methodName"/> method on the <paramref name="builderType"/> type.
            </summary>
            <param name="builderType">The type of the builder to use to construct the collection.</param>
            <param name="methodName">The name of the method on the builder to use to construct the collection.</param>
            <remarks>
            <paramref name="methodName"/> must refer to a static method that accepts a single parameter of
            type <see cref="T:System.ReadOnlySpan`1"/> and returns an instance of the collection being built containing
            a copy of the data from that span.  In future releases of .NET, additional patterns may be supported.
            </remarks>
        </member>
        <member name="P:System.Runtime.CompilerServices.CollectionBuilderAttribute.BuilderType">
            <summary>
            Gets the type of the builder to use to construct the collection.
            </summary>
        </member>
        <member name="P:System.Runtime.CompilerServices.CollectionBuilderAttribute.MethodName">
            <summary>
            Gets the name of the method on the builder to use to construct the collection.
            </summary>
            <remarks>
            This should match the metadata name of the target method.
            For example, this might be ".ctor" if targeting the type's constructor.
            </remarks>
        </member>
        <member name="T:System.Runtime.CompilerServices.CompilerFeatureRequiredAttribute">
            <summary>
            Indicates that compiler support for a particular feature is required for the location where this attribute is applied.
            </summary>
        </member>
        <member name="M:System.Runtime.CompilerServices.CompilerFeatureRequiredAttribute.#ctor(System.String)">
            <summary>
            Creates a new instance of the <see cref="T:System.Runtime.CompilerServices.CompilerFeatureRequiredAttribute"/> type.
            </summary>
            <param name="featureName">The name of the feature to indicate.</param>
        </member>
        <member name="P:System.Runtime.CompilerServices.CompilerFeatureRequiredAttribute.FeatureName">
            <summary>
            The name of the compiler feature.
            </summary>
        </member>
        <member name="P:System.Runtime.CompilerServices.CompilerFeatureRequiredAttribute.IsOptional">
            <summary>
            If true, the compiler can choose to allow access to the location where this attribute is applied if it does not understand <see cref="P:System.Runtime.CompilerServices.CompilerFeatureRequiredAttribute.FeatureName"/>.
            </summary>
        </member>
        <member name="F:System.Runtime.CompilerServices.CompilerFeatureRequiredAttribute.RefStructs">
            <summary>
            The <see cref="P:System.Runtime.CompilerServices.CompilerFeatureRequiredAttribute.FeatureName"/> used for the ref structs C# feature.
            </summary>
        </member>
        <member name="F:System.Runtime.CompilerServices.CompilerFeatureRequiredAttribute.RequiredMembers">
            <summary>
            The <see cref="P:System.Runtime.CompilerServices.CompilerFeatureRequiredAttribute.FeatureName"/> used for the required members C# feature.
            </summary>
        </member>
        <member name="T:System.Runtime.CompilerServices.InterpolatedStringHandlerArgumentAttribute">
            <summary>
            Indicates which arguments to a method involving an interpolated string handler should be passed to that handler.
            </summary>
        </member>
        <member name="M:System.Runtime.CompilerServices.InterpolatedStringHandlerArgumentAttribute.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:System.Runtime.CompilerServices.InterpolatedStringHandlerArgumentAttribute"/> class.
            </summary>
            <param name="argument">The name of the argument that should be passed to the handler.</param>
            <remarks><see langword="null"/> may be used as the name of the receiver in an instance method.</remarks>
        </member>
        <member name="M:System.Runtime.CompilerServices.InterpolatedStringHandlerArgumentAttribute.#ctor(System.String[])">
            <summary>
            Initializes a new instance of the <see cref="T:System.Runtime.CompilerServices.InterpolatedStringHandlerArgumentAttribute"/> class.
            </summary>
            <param name="arguments">The names of the arguments that should be passed to the handler.</param>
            <remarks><see langword="null"/> may be used as the name of the receiver in an instance method.</remarks>
        </member>
        <member name="P:System.Runtime.CompilerServices.InterpolatedStringHandlerArgumentAttribute.Arguments">
            <summary>
            Gets the names of the arguments that should be passed to the handler.
            </summary>
            <remarks><see langword="null"/> may be used as the name of the receiver in an instance method.</remarks>
        </member>
        <member name="T:System.Runtime.CompilerServices.InterpolatedStringHandlerAttribute">
            <summary>
            Indicates the attributed type is to be used as an interpolated string handler.
            </summary>
        </member>
        <member name="T:System.Runtime.CompilerServices.IsExternalInit">
            <summary>
            Reserved to be used by the compiler for tracking metadata.
            This class should not be used by developers in source code.
            </summary>
        </member>
        <member name="T:System.Runtime.CompilerServices.ModuleInitializerAttribute">
             <summary>
             Used to indicate to the compiler that a method should be called
             in its containing module's initializer.
             </summary>
             <remarks>
             When one or more valid methods
             with this attribute are found in a compilation, the compiler will
             emit a module initializer which calls each of the attributed methods.
            
             Certain requirements are imposed on any method targeted with this attribute:
             - The method must be `static`.
             - The method must be an ordinary member method, as opposed to a property accessor, constructor, local function, etc.
             - The method must be parameterless.
             - The method must return `void`.
             - The method must not be generic or be contained in a generic type.
             - The method's effective accessibility must be `internal` or `public`.
            
             The specification for module initializers in the .NET runtime can be found here:
             https://github.com/dotnet/runtime/blob/main/docs/design/specs/Ecma-335-Augments.md#module-initializer
             </remarks>
        </member>
        <member name="T:System.Runtime.CompilerServices.RequiredMemberAttribute">
            <summary>
            Specifies that a type has required members or that a member is required.
            </summary>
        </member>
        <member name="T:System.Runtime.CompilerServices.RequiresLocationAttribute">
            <summary>
            Reserved for use by a compiler for tracking metadata.
            This attribute should not be used by developers in source code.
            </summary>
        </member>
        <member name="T:System.Runtime.CompilerServices.SkipLocalsInitAttribute">
            <summary>
            Used to indicate to the compiler that the <c>.locals init</c> flag should not be set in method headers.
            </summary>
        </member>
        <member name="M:System.Runtime.Versioning.RequiresPreviewFeaturesAttribute.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:System.Runtime.Versioning.RequiresPreviewFeaturesAttribute"/> class.
            </summary>
        </member>
        <member name="M:System.Runtime.Versioning.RequiresPreviewFeaturesAttribute.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:System.Runtime.Versioning.RequiresPreviewFeaturesAttribute"/> class with the specified message.
            </summary>
            <param name="message">An optional message associated with this attribute instance.</param>
        </member>
        <member name="P:System.Runtime.Versioning.RequiresPreviewFeaturesAttribute.Message">
            <summary>
            Returns the optional message associated with this attribute instance.
            </summary>
        </member>
        <member name="P:System.Runtime.Versioning.RequiresPreviewFeaturesAttribute.Url">
            <summary>
            Returns the optional URL associated with this attribute instance.
            </summary>
        </member>
        <member name="T:BizHawk.Common.BPSPatcher.BPSPayload">
            <remarks>
            constructor assumes valid header/footer<br/>
            https://github.com/Alcaro/Flips/blob/master/bps_spec.md
            </remarks>
            <seealso cref="M:BizHawk.Common.BPSPatcher.IsBPSFile(System.ReadOnlySpan{System.Byte},BizHawk.Common.BPSPatcher.BPSPayload@)"/>
        </member>
        <member name="M:BizHawk.Common.BPSPatcher.BPSPayload.#ctor(System.ReadOnlySpan{System.Byte})">
            <remarks>assumes valid header/footer</remarks>
            <seealso cref="M:BizHawk.Common.BPSPatcher.IsBPSFile(System.ReadOnlySpan{System.Byte},BizHawk.Common.BPSPatcher.BPSPayload@)"/>
        </member>
        <member name="M:BizHawk.Common.BPSPatcher.BPSPayload.DoPatch(System.ReadOnlySpan{System.Byte},System.Span{System.Byte})">
            <returns><see langword="true"/> iff checksums of base rom and result both matched</returns>
        </member>
        <member name="T:BizHawk.Common.BPSPatcher.IPSPayload">
            <remarks>
            constructor assumes valid header/footer<br/>
            https://zerosoft.zophar.net/ips.php
            </remarks>
            <seealso cref="M:BizHawk.Common.BPSPatcher.IsIPSFile(System.ReadOnlySpan{System.Byte})"/>
        </member>
        <member name="M:BizHawk.Common.BPSPatcher.IPSPayload.#ctor(System.ReadOnlySpan{System.Byte})">
            <remarks>assumes valid header/footer</remarks>
            <seealso cref="M:BizHawk.Common.BPSPatcher.IsIPSFile(System.ReadOnlySpan{System.Byte})"/>
        </member>
        <member name="M:BizHawk.Common.BPSPatcher.Patch(System.ReadOnlySpan{System.Byte},BizHawk.Common.BPSPatcher.BPSPayload,System.Boolean@)">
            <remarks>always allocates a new array</remarks>
        </member>
        <member name="M:BizHawk.Common.BPSPatcher.Patch(System.Byte[],BizHawk.Common.BPSPatcher.IPSPayload)">
            <remarks>may patch in place, returning <paramref name="baseRom"/>, or allocate a new array</remarks>
        </member>
        <member name="M:BizHawk.Common.BPSPatcher.TryPatchInPlace(System.Span{System.Byte},BizHawk.Common.BPSPatcher.IPSPayload)">
            <remarks>is this even useful?</remarks>
        </member>
        <member name="T:BizHawk.Common.CRC32">
            <remarks>Implementation of CRC-32 (i.e. POSIX cksum), intended for comparing discs against the Redump.org database</remarks>
        </member>
        <member name="F:BizHawk.Common.CRC32.POLYNOMIAL_CONST">
            <remarks>coefficients of the polynomial, in the format Wikipedia calls "reversed"</remarks>
        </member>
        <member name="F:BizHawk.Common.CRC32._calcCRC">
            <summary>
            Delegate to unmanaged code that actually does the calculation.
            This may be hardware accelerated, if the CPU supports such.
            </summary>
        </member>
        <member name="P:BizHawk.Common.CRC32.Current">
            <summary>The raw non-negated output</summary>
        </member>
        <member name="P:BizHawk.Common.CRC32.Result">
            <summary>The negated output (the typical result of the CRC calculation)</summary>
        </member>
        <member name="M:BizHawk.Common.CRC32.Incorporate(System.UInt32,System.Int32)">
            <summary>
            Incorporates a pre-calculated CRC with the given length by combining crcs<br/>
            It's a bit flaky, so be careful, but it works
            </summary>
            <remarks>algorithm from zlib's crc32_combine. read http://www.leapsecond.com/tools/crcomb.c for more</remarks>
        </member>
        <member name="T:BizHawk.Common.CRC32Checksum">
            <summary>uses <see cref="T:BizHawk.Common.CRC32">custom implementation</see> of CRC-32 (i.e. POSIX cksum)</summary>
            <seealso cref="T:BizHawk.Common.MD5Checksum"/>
            <seealso cref="T:BizHawk.Common.SHA1Checksum"/>
            <seealso cref="T:BizHawk.Common.SHA256Checksum"/>
        </member>
        <member name="F:BizHawk.Common.CRC32Checksum.EXPECTED_LENGTH">
            <remarks>in bits</remarks>
        </member>
        <member name="T:BizHawk.Common.MD5Checksum">
            <summary>uses <see cref="T:System.Security.Cryptography.MD5"/> implementation from BCL</summary>
            <seealso cref="T:BizHawk.Common.CRC32Checksum"/>
            <seealso cref="T:BizHawk.Common.SHA1Checksum"/>
            <seealso cref="T:BizHawk.Common.SHA256Checksum"/>
        </member>
        <member name="F:BizHawk.Common.MD5Checksum.EXPECTED_LENGTH">
            <remarks>in bits</remarks>
        </member>
        <member name="T:BizHawk.Common.SHA1Checksum">
            <summary>uses <see cref="T:System.Security.Cryptography.SHA1"/> implementation from BCL</summary>
            <seealso cref="T:BizHawk.Common.CRC32Checksum"/>
            <seealso cref="T:BizHawk.Common.MD5Checksum"/>
            <seealso cref="T:BizHawk.Common.SHA256Checksum"/>
        </member>
        <member name="F:BizHawk.Common.SHA1Checksum.EXPECTED_LENGTH">
            <remarks>in bits</remarks>
        </member>
        <member name="T:BizHawk.Common.SHA256Checksum">
            <summary>uses <see cref="T:System.Security.Cryptography.SHA256"/> implementation from BCL</summary>
            <seealso cref="T:BizHawk.Common.CRC32Checksum"/>
            <seealso cref="T:BizHawk.Common.MD5Checksum"/>
            <seealso cref="T:BizHawk.Common.SHA1Checksum"/>
        </member>
        <member name="F:BizHawk.Common.SHA256Checksum.EXPECTED_LENGTH">
            <remarks>in bits</remarks>
        </member>
        <member name="M:BizHawk.Common.Colors.ARGB(System.Byte,System.Byte,System.Byte,System.Byte)">
            <remarks>This is just <c>Color.FromArgb(alpha, red, green, blue).ToArgb()</c> with extra steps.</remarks>
        </member>
        <member name="T:BizHawk.Common.Bag`2">
            <summary>Wrapper over <see cref="T:BizHawk.Common.WorkingDictionary`2">WorkingDictionary</see>&lt;<typeparamref name="TKey"/>, <see cref="T:System.Collections.Generic.List`1">List</see>&lt;<typeparamref name="TValue"/>>>.</summary>
        </member>
        <member name="M:BizHawk.Common.SortedList`1.Max">
            <remarks>throws if list is empty</remarks>
        </member>
        <member name="M:BizHawk.Common.SortedList`1.Min">
            <remarks>throws if list is empty</remarks>
        </member>
        <member name="M:BizHawk.Common.SortedList`1.RemoveAfter(`0)">
            <summary>Remove all items after the specific item (but not the given item).</summary>
        </member>
        <member name="T:BizHawk.Common.WorkingDictionary`2">
            <summary>A dictionary whose index getter creates an entry if the requested key isn't part of the collection, making it always safe to use the returned value. The new entry's value will be the result of the default constructor of <typeparamref name="TValue"/>.</summary>
        </member>
        <member name="T:BizHawk.Common.DeepEqualsIgnoreAttribute">
            <summary>Annotated fields will not be used by <see cref="T:BizHawk.Common.DeepEquality"/> for comparison.</summary>
        </member>
        <member name="M:BizHawk.Common.DeepEquality.IsNonZeroBasedArray(System.Type)">
            <summary>
            return true if an array type is not 0-based
            </summary>
        </member>
        <member name="M:BizHawk.Common.DeepEquality.GetAllFields(System.Type)">
            <summary>
            return all instance fields of a type
            </summary>
        </member>
        <member name="M:BizHawk.Common.DeepEquality.ArrayEquals``1(``0[],``0[])">
            <summary>
            test if two arrays are equal in contents; arrays should have same type
            </summary>
        </member>
        <member name="M:BizHawk.Common.DeepEquality.DeepEquals(System.Object,System.Object)">
            <summary>test if two objects <paramref name="o1"/> and <paramref name="o2"/> are equal, field-by-field (with deep inspection of each field)</summary>
            <exception cref="T:System.InvalidOperationException"><paramref name="o1"/> is an array with rank > 1 or is a non-zero-indexed array</exception>
        </member>
        <member name="T:BizHawk.Common.DeltaSerializer">
            <summary>
            Serializes deltas between data, mainly for ROM like structures which are actually writable, and therefore the differences need to be saved
            Uses a simple delta format in order to keep size down
            DELTA FORMAT DETAILS FOLLOWS
            The format comprises of an indeterminate amount of blocks. These blocks start with a 4 byte header. This header is read as a native endian 32-bit two's complement signed integer.
            If the header is positive, then the header indicates the amount of bytes which are identical between the original and current spans.
            Positive headers are blocks by themselves, so the next header will proceed immediately after a positive header.
            If the header is negative, then the header indicates the negation of the amount of bytes which differ between the original and current spans.
            A negative header will have the negated header amount of bytes proceed it, which will be the bitwise XOR between the original and differing bytes.
            A header of -0x80000000 is considered ill-formed.
            This format does not stipulate requirements for whether blocks of non-differing bytes necessarily will use a positive header.
            Thus, an implementation is free to use negative headers only, although without combination of positive headers, this will obviously not have great results wrt final size.
            More practically, an implementation may want to avoid using positive headers when the block is rather small (e.g. smaller than the header itself, and thus not shrinking the result).
            Subsequently, it may not mind putting some identical bytes within the negative header's block.
            XORing the same values result in 0, so doing this will not leave trace of the original data.
            </summary>
        </member>
        <member name="M:BizHawk.Common.EndiannessUtils.MutatingByteSwap16(System.Span{System.Byte})">
            <summary>reverses pairs of octets in-place: <c>0xAABBIIJJPPQQYYZZ</c> &lt;=> <c>0xBBAAJJIIQQPPZZYY</c></summary>
        </member>
        <member name="M:BizHawk.Common.EndiannessUtils.MutatingByteSwap32(System.Span{System.Byte})">
            <summary>reverses groups of 4 octets in-place: <c>0xAABBCCDDWWXXYYZZ</c> &lt;=> <c>0xDDCCBBAAZZYYXXWW</c></summary>
        </member>
        <member name="M:BizHawk.Common.EndiannessUtils.MutatingShortSwap32(System.Span{System.Byte})">
            <summary>swaps pairs of 16-bit words in-place: <c>0xAABBIIJJPPQQYYZZ</c> &lt;=> <c>0xIIJJAABBYYZZPPQQ</c></summary>
        </member>
        <member name="M:BizHawk.Common.BufferExtensions.BufferExtensions.ReadFromHexFast(System.Byte[],System.String)">
            <exception cref="T:System.Exception"><paramref name="buffer"/> can't hold the same number of bytes as <paramref name="hex"/></exception>
        </member>
        <member name="M:BizHawk.Common.BufferExtensions.BufferExtensions.BytesToHexString(System.ReadOnlySpan{System.Byte})">
            <summary>Creates a string containing the hexadecimal representation of <paramref name="bytes"/></summary>
            <remarks>Output format is all-uppercase, no spaces, padded to an even number of nybbles, no prefix</remarks>
        </member>
        <member name="M:BizHawk.Common.BufferExtensions.BufferExtensions.BytesToHexString(System.Collections.Generic.IReadOnlyList{System.Byte})">
            <inheritdoc cref="M:BizHawk.Common.BufferExtensions.BufferExtensions.BytesToHexString(System.ReadOnlySpan{System.Byte})"/>
        </member>
        <member name="M:BizHawk.Common.CollectionExtensions.CollectionExtensions.LowerBoundBinarySearch``2(System.Collections.Generic.IList{``0},System.Func{``0,``1},``1)">
            <summary>Implements an indirected binary search.</summary>
            <return>
            The index of the element whose key matches <paramref name="key"/>;
            or if none match, the index of the element whose key is closest and lower;
            or if all elements' keys are higher, <c>-1</c>.<br/>
            (Equivalently: If none match, 1 less than the index where inserting an element with the given <paramref name="key"/> would keep the list sorted)
            </return>
            <remarks>The returned index may not be accurate if <paramref name="list"/> is not sorted in ascending order with respect to <paramref name="keySelector"/>.</remarks>
        </member>
        <member name="M:BizHawk.Common.CollectionExtensions.CollectionExtensions.BinarySearch``2(System.Collections.Generic.IList{``0},System.Func{``0,``1},``1)">
            <exception cref="T:System.InvalidOperationException"><paramref name="key"/> not found after mapping <paramref name="keySelector"/> over <paramref name="list"/></exception>
            <remarks>implementation from https://stackoverflow.com/a/1766369/7467292</remarks>
        </member>
        <member name="M:BizHawk.Common.CollectionExtensions.CollectionExtensions.AddRange``1(System.Collections.Generic.ICollection{``0},System.Collections.Generic.IEnumerable{``0})">
            <inheritdoc cref="M:System.Collections.Generic.List`1.AddRange(System.Collections.Generic.IEnumerable{`0})"/>
            <remarks>
            (This is an extension method which reimplements <see cref="M:System.Collections.Generic.List`1.AddRange(System.Collections.Generic.IEnumerable{`0})"/> for other <see cref="T:System.Collections.Generic.ICollection`1">collections</see>.
            It defers to the existing <see cref="M:System.Collections.Generic.List`1.AddRange(System.Collections.Generic.IEnumerable{`0})">AddRange</see> if the receiver's type is <see cref="T:System.Collections.Generic.List`1"/> or a subclass.)
            </remarks>
        </member>
        <member name="M:BizHawk.Common.CollectionExtensions.CollectionExtensions.ConcatArray``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0},System.Span{``0})">
            <returns>
            portion of <paramref name="dest"/> that was written to,
            unless either span is empty, in which case the other reference is returned<br/>
            if <paramref name="dest"/> is too small, returns <see cref="P:System.Span`1.Empty"/>
            </returns>
        </member>
        <member name="M:BizHawk.Common.CollectionExtensions.CollectionExtensions.ConcatArray``1(``0[],``0[])">
            <returns>freshly-allocated array, unless either array is empty, in which case the other reference is returned</returns>
        </member>
        <member name="M:BizHawk.Common.CollectionExtensions.CollectionExtensions.GetValueOrDefault``2(System.Collections.Generic.IReadOnlyDictionary{``0,``1},``0)">
            <summary>
            Returns the value at <paramref name="key"/>.
            If the key is not present, returns default(TValue).
            backported from .NET Core 2.0
            </summary>
        </member>
        <member name="M:BizHawk.Common.CollectionExtensions.CollectionExtensions.GetValueOrDefault``2(System.Collections.Generic.IReadOnlyDictionary{``0,``1},``0,``1)">
            <summary>
            Returns the value at <paramref name="key"/>.
            If the key is not present, returns <paramref name="defaultValue"/>.
            backported from .NET Core 2.0
            </summary>
        </member>
        <member name="M:BizHawk.Common.CollectionExtensions.CollectionExtensions.GetValueOrPut``2(System.Collections.Generic.IDictionary{``0,``1},``0,System.Func{``0,``1})">
            <summary>
            Returns the value at <paramref name="key"/>.
            If the key is not present, stores the result of <c>defaultValue(key)</c> in the dict, and then returns that.
            </summary>
        </member>
        <member name="M:BizHawk.Common.CollectionExtensions.CollectionExtensions.GetValueOrPutNew``2(System.Collections.Generic.IDictionary{``0,``1},``0)">
            <summary>
            Returns the value at <paramref name="key"/>.
            If the key is not present, stores the result of <c>new TValue()</c> in the dict, and then returns that.
            </summary>
        </member>
        <member name="M:BizHawk.Common.CollectionExtensions.CollectionExtensions.GetValueOrPutNew1``2(System.Collections.Generic.IDictionary{``0,``1},``0)">
            <summary>
            Returns the value at <paramref name="key"/>.
            If the key is not present, stores the result of <c>new TValue(key)</c> in the dict, and then returns that.
            </summary>
            <remarks>
            Will throw if such a constructor does not exist, or exists but is not <see langword="public"/>.<br/>
            TODO is <see cref="M:System.Activator.CreateInstance(System.Type,System.Object[])"/> fast enough?
            I suppose it's not that important because it's called on cache miss --yoshi
            </remarks>
        </member>
        <member name="M:BizHawk.Common.CollectionExtensions.CollectionExtensions.IndexOf``1(System.Collections.Generic.IReadOnlyList{``0},``0)">
            <inheritdoc cref="M:System.Collections.Generic.IList`1.IndexOf(`0)"/>
            <remarks>
            (This is an extension method which reimplements <see cref="M:System.Collections.Generic.IList`1.IndexOf(`0)"/> for other <see cref="T:System.Collections.Generic.IReadOnlyList`1">collections</see>.
            It defers to the existing <see cref="M:System.Collections.Generic.IList`1.IndexOf(`0)">IndexOf</see> if the receiver's type is <see cref="T:System.Collections.Generic.IList`1"/> or a subtype.)
            </remarks>
        </member>
        <member name="M:BizHawk.Common.CollectionExtensions.CollectionExtensions.Order``1(System.Collections.Generic.IEnumerable{``0})">
            <remarks>shorthand for <c>this.OrderBy(static e => e)</c>, backported from .NET 7</remarks>
        </member>
        <member name="M:BizHawk.Common.CollectionExtensions.CollectionExtensions.OrderDescending``1(System.Collections.Generic.IEnumerable{``0})">
            <remarks>shorthand for <c>this.OrderByDescending(static e => e)</c>, backported from .NET 7</remarks>
        </member>
        <member name="M:BizHawk.Common.CollectionExtensions.CollectionExtensions.RemoveAll``1(System.Collections.Generic.ICollection{``0},System.Func{``0,System.Boolean})">
            <inheritdoc cref="M:System.Collections.Generic.List`1.RemoveAll(System.Predicate{`0})"/>
            <remarks>
            (This is an extension method which reimplements <see cref="M:System.Collections.Generic.List`1.RemoveAll(System.Predicate{`0})"/> for other <see cref="T:System.Collections.Generic.ICollection`1">collections</see>.
            It defers to the existing <see cref="M:System.Collections.Generic.List`1.RemoveAll(System.Predicate{`0})">RemoveAll</see> if the receiver's type is <see cref="T:System.Collections.Generic.List`1"/> or a subclass.)
            </remarks>
        </member>
        <member name="M:BizHawk.Common.CollectionExtensions.CollectionExtensions.ToDictionary``2(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{``0,``1}})">
            <summary>shallow clone</summary>
        </member>
        <member name="M:BizHawk.Common.IOExtensions.IOExtensions.ReadStringFixedUtf8(System.IO.BinaryReader,System.Int32)">
            <summary>
            Read a string from a binary reader using utf8 encoding and known byte length
            </summary>
            <param name="bytes">exact number of bytes to read</param>
        </member>
        <member name="M:BizHawk.Common.IOExtensions.IOExtensions.ReadStringUtf8NullTerminated(System.IO.BinaryReader)">
            <summary>
            Read a null terminated string from a binary reader using utf8 encoding
            </summary>
        </member>
        <member name="M:BizHawk.Common.NumberExtensions.NumberExtensions.NumHexDigits(System.Int64)">
            <summary>
            Receives a number and returns the number of hexadecimal digits it is
            Note: currently only returns 2, 4, 6, or 8
            </summary>
        </member>
        <member name="M:BizHawk.Common.NumberExtensions.NumberExtensions.Mod(System.Int32,System.Int32)">
            <summary>
            The % operator is a remainder operator. (e.g. -1 mod 4 returns -1, not 3.)
            </summary>
        </member>
        <member name="M:BizHawk.Common.NumberExtensions.NumberExtensions.Clamp``1(``0,``0,``0)">
            <summary>
            Force the value to be strictly between min and max (both excluded)
            </summary>
            <typeparam name="T">Anything that implements <see cref="T:System.IComparable`1"/></typeparam>
            <param name="val">Value that will be clamped</param>
            <param name="min">Minimum allowed</param>
            <param name="max">Maximum allowed</param>
            <returns>The value if strictly between min and max; otherwise min (or max depending of what is passed)</returns>
        </member>
        <member name="F:BizHawk.Common.NumberExtensions.NumberExtensions.ExtremelySmallNumber">
            <summary>2^-53</summary>
        </member>
        <member name="M:BizHawk.Common.NumberExtensions.NumberExtensions.HawkFloatEquality(System.Double,System.Double,System.Double)">
            <inheritdoc cref="M:BizHawk.Common.NumberExtensions.NumberExtensions.HawkFloatEquality(System.Single,System.Single,System.Single)"/>
        </member>
        <member name="F:BizHawk.Common.NumberExtensions.NumberExtensions.ReallySmallNumber">
            <summary>2^-24</summary>
        </member>
        <member name="M:BizHawk.Common.NumberExtensions.NumberExtensions.HawkFloatEquality(System.Single,System.Single,System.Single)">
            <remarks>don't use this in cores without picking a suitable ε</remarks>
        </member>
        <member name="M:BizHawk.Common.NumberExtensions.NumberExtensions.ReinterpretAsF32(System.UInt32)">
            <summary> Reinterprets the byte representation of <paramref name="value"/> as a float</summary>
        </member>
        <member name="M:BizHawk.Common.NumberExtensions.NumberExtensions.ReinterpretAsUInt32(System.Single)">
            <summary> Reinterprets the byte representation of <paramref name="value"/> as a uint</summary>
        </member>
        <member name="T:BizHawk.Common.StringExtensions.NumericStringExtensions">
            <remarks>TODO how many of these methods can be replaced with <see cref="M:System.Int32.TryParse(System.String,System.Int32@)">int.TryParse</see> or similar? --yoshi</remarks>
        </member>
        <member name="M:BizHawk.Common.StringExtensions.NumericStringExtensions.IsBinary(System.Char)">
            <returns><see langword="true"/> iff <paramref name="c"/> is either <c>'0'</c> or <c>'1'</c></returns>
        </member>
        <member name="M:BizHawk.Common.StringExtensions.NumericStringExtensions.IsBinary(System.String)">
            <returns><see langword="true"/> iff <paramref name="str"/> is not <see langword="null"/> and all chars of <paramref name="str"/> are either <c>'0'</c> or <c>'1'</c></returns>
            <remarks><paramref name="str"/> should exclude the prefix <c>0b</c></remarks>
        </member>
        <member name="M:BizHawk.Common.StringExtensions.NumericStringExtensions.IsHex(System.Char)">
            <returns><see langword="true"/> iff <paramref name="c"/> is a hex digit (<c>[0-9A-Fa-f]</c>)</returns>
        </member>
        <member name="M:BizHawk.Common.StringExtensions.NumericStringExtensions.IsHex(System.String)">
            <returns><see langword="true"/> iff <paramref name="str"/> is not <see langword="null"/> and all chars of <paramref name="str"/> are hex digits (<c>[0-9A-Fa-f]</c>)</returns>
            <remarks><paramref name="str"/> should exclude the prefix <c>0x</c></remarks>
        </member>
        <member name="M:BizHawk.Common.StringExtensions.NumericStringExtensions.IsSigned(System.Char)">
            <returns><see langword="true"/> iff <paramref name="c"/> is <c>'-'</c> or a digit</returns>
        </member>
        <member name="M:BizHawk.Common.StringExtensions.NumericStringExtensions.IsUnsigned(System.Char)">
            <returns><see langword="true"/> iff <paramref name="c"/> is a digit</returns>
        </member>
        <member name="M:BizHawk.Common.StringExtensions.NumericStringExtensions.OnlyHex(System.String)">
            <returns>
            A copy of <paramref name="raw"/> with characters removed so that the whole thing passes <see cref="M:BizHawk.Common.StringExtensions.NumericStringExtensions.IsHex(System.String)">IsHex</see>.<br/>
            That is, all chars of the copy will be hex digits (<c>[0-9A-F]</c>).
            </returns>
        </member>
        <member name="M:BizHawk.Common.StringExtensions.NumericStringExtensions.CleanHex(System.String)">
            <returns>
            A copy of <paramref name="raw"/> in uppercase after removing <c>0x</c>/<c>$</c> prefixes and all whitespace, or
            <see cref="F:System.String.Empty"/> if <paramref name="raw"/> contains other non-hex characters.
            </returns>
        </member>
        <member name="M:BizHawk.Common.StringExtensions.NumericStringExtensions.IsUnsigned(System.String)">
            <returns><see langword="true"/> iff <paramref name="str"/> is not <see langword="null"/> and all chars of <paramref name="str"/> are digits</returns>
        </member>
        <member name="M:BizHawk.Common.StringExtensions.StringExtensions.In(System.String,System.String[])">
            <returns>
            <see langword="true"/> if <paramref name="str"/> appears in <paramref name="options"/> (case-insensitive)
            </returns>
        </member>
        <member name="M:BizHawk.Common.StringExtensions.StringExtensions.RemovePrefix(System.String,System.Char)">
            <returns>
            <paramref name="str"/> with the first char removed, or
            the original <paramref name="str"/> if the first char of <paramref name="str"/> is not <paramref name="prefix"/>
            </returns>
        </member>
        <member name="M:BizHawk.Common.StringExtensions.StringExtensions.RemovePrefix(System.String,System.Char,System.String)">
            <returns>
            <paramref name="str"/> with the first char removed, or
            <paramref name="notFoundValue"/> if the first char of <paramref name="str"/> is not <paramref name="prefix"/>
            </returns>
        </member>
        <member name="M:BizHawk.Common.StringExtensions.StringExtensions.RemovePrefix(System.String,System.String)">
            <returns>
            <paramref name="str"/> with the leading substring <paramref name="prefix"/> removed, or
            the original <paramref name="str"/> if <paramref name="str"/> does not start with <paramref name="prefix"/>
            </returns>
        </member>
        <member name="M:BizHawk.Common.StringExtensions.StringExtensions.RemovePrefix(System.String,System.String,System.String)">
            <returns>
            <paramref name="str"/> with the leading substring <paramref name="prefix"/> removed, or
            <paramref name="notFoundValue"/> if <paramref name="str"/> does not start with <paramref name="prefix"/>
            </returns>
        </member>
        <member name="M:BizHawk.Common.StringExtensions.StringExtensions.RemoveSuffix(System.String,System.Char)">
            <returns>
            <paramref name="str"/> with the last char removed, or
            the original <paramref name="str"/> if the last char of <paramref name="str"/> is not <paramref name="suffix"/>
            </returns>
        </member>
        <member name="M:BizHawk.Common.StringExtensions.StringExtensions.RemoveSuffix(System.String,System.String)">
            <returns>
            <paramref name="str"/> with the trailing substring <paramref name="suffix"/> removed, or
            the original <paramref name="str"/> if <paramref name="str"/> does not end with <paramref name="suffix"/>
            </returns>
        </member>
        <member name="M:BizHawk.Common.StringExtensions.StringExtensions.RemoveSuffix(System.String,System.String,System.String)">
            <returns>
            <paramref name="str"/> with the trailing substring <paramref name="suffix"/> removed, or
            <paramref name="notFoundValue"/> if <paramref name="str"/> does not end with <paramref name="suffix"/>
            </returns>
        </member>
        <member name="M:BizHawk.Common.StringExtensions.StringExtensions.SubstringAfter(System.String,System.String)">
            <returns>
            the substring of <paramref name="str"/> after the first occurrence of <paramref name="delimiter"/>, or
            the original <paramref name="str"/> if not found
            </returns>
        </member>
        <member name="M:BizHawk.Common.StringExtensions.StringExtensions.SubstringAfter(System.String,System.String,System.String)">
            <returns>
            the substring of <paramref name="str"/> after the first occurrence of <paramref name="delimiter"/>, or
            <paramref name="notFoundValue"/> if not found
            </returns>
        </member>
        <member name="M:BizHawk.Common.StringExtensions.StringExtensions.SubstringAfterLast(System.String,System.Char)">
            <returns>
            the substring of <paramref name="str"/> after the last occurrence of <paramref name="delimiter"/>, or
            the original <paramref name="str"/> if not found
            </returns>
        </member>
        <member name="M:BizHawk.Common.StringExtensions.StringExtensions.SubstringAfterLast(System.String,System.Char,System.String)">
            <returns>
            the substring of <paramref name="str"/> after the last occurrence of <paramref name="delimiter"/>, or
            <paramref name="notFoundValue"/> if not found
            </returns>
        </member>
        <member name="M:BizHawk.Common.StringExtensions.StringExtensions.SubstringBefore(System.String,System.Char)">
            <returns>
            the substring of <paramref name="str"/> before the first occurrence of <paramref name="delimiter"/>, or
            the original <paramref name="str"/> if not found
            </returns>
        </member>
        <member name="M:BizHawk.Common.StringExtensions.StringExtensions.SubstringBefore(System.String,System.Char,System.String)">
            <returns>
            the substring of <paramref name="str"/> before the first occurrence of <paramref name="delimiter"/>, or
            <paramref name="notFoundValue"/> if not found
            </returns>
        </member>
        <member name="M:BizHawk.Common.StringExtensions.StringExtensions.SubstringBeforeLast(System.String,System.Char)">
            <returns>
            the substring of <paramref name="str"/> before the last occurrence of <paramref name="delimiter"/>, or
            the original <paramref name="str"/> if not found
            </returns>
        </member>
        <member name="M:BizHawk.Common.StringExtensions.StringExtensions.SubstringBeforeLast(System.String,System.Char,System.String)">
            <returns>
            the substring of <paramref name="str"/> before the last occurrence of <paramref name="delimiter"/>, or
            <paramref name="notFoundValue"/> if not found
            </returns>
        </member>
        <member name="M:BizHawk.Common.StringExtensions.StringExtensions.SubstringBeforeOrNull(System.String,System.String)">
            <returns>
            the substring of <paramref name="str"/> before the first occurrence of <paramref name="delimiter"/>, or
            <see langword="null"/> if not found
            </returns>
        </member>
        <member name="M:BizHawk.Common.StringExtensions.StringExtensions.TransformFields(System.String,System.Char,System.Func{System.String,System.String})">
            <summary>
            splits a given <paramref name="str"/> by <paramref name="delimiter"/>,
            applies <paramref name="transform"/> to each part, then rejoins them
            </summary>
            <remarks><c>"abc,def,ghi".TransformFields(',', s => s.Reverse()) == "cba,fed,ihg"</c></remarks>
        </member>
        <member name="M:BizHawk.Common.PathExtensions.PathExtensions.IsSubfolderOf(System.String,System.String)">
            <returns><see langword="true"/> iff <paramref name="childPath"/> indicates a child of <paramref name="parentPath"/>, with <see langword="false"/> being returned if either path is <see langword="null"/></returns>
            <remarks>algorithm for Windows taken from https://stackoverflow.com/a/7710620/7467292</remarks>
        </member>
        <member name="M:BizHawk.Common.PathExtensions.PathExtensions.IsAbsolute(System.String)">
            <returns><see langword="true"/> iff absolute (OS-dependent)</returns>
            <seealso cref="M:BizHawk.Common.PathExtensions.PathExtensions.IsRelative(System.String)"/>
        </member>
        <member name="M:BizHawk.Common.PathExtensions.PathExtensions.IsRelative(System.String)">
            <returns><see langword="false"/> iff absolute (OS-dependent)</returns>
            <remarks>that means it may return <see langword="true"/> for invalid paths</remarks>
            <seealso cref="M:BizHawk.Common.PathExtensions.PathExtensions.IsAbsolute(System.String)"/>
        </member>
        <member name="M:BizHawk.Common.PathExtensions.PathExtensions.GetRelativePath(System.String,System.String)">
            <exception cref="T:System.ArgumentException">running on Windows host, and unmanaged call failed</exception>
            <exception cref="T:System.IO.FileNotFoundException">running on Windows host, and either path is not a regular file or directory</exception>
            <remarks>
            always returns a relative path, even if it means going up first<br/>
            algorithm for Windows taken from https://stackoverflow.com/a/485516/7467292<br/>
            the parameter names seem backwards, but those are the names used in the Win32 API we're calling
            </remarks>
        </member>
        <member name="M:BizHawk.Common.PathExtensions.PathExtensions.MakeAbsolute(System.String,System.String)">
            <returns>absolute path (OS-dependent) equivalent to <paramref name="path"/></returns>
            <remarks>
            unless <paramref name="cwd"/> is given, uses <see cref="M:BizHawk.Common.CWDHacks.Get">CWDHacks.Get</see>/<see cref="P:System.Environment.CurrentDirectory">Environment.CurrentDirectory</see>,
            so take care when calling this after startup
            </remarks>
        </member>
        <member name="M:BizHawk.Common.PathExtensions.PathExtensions.MakeProgramRelativePath(System.String)">
            <returns>the absolute path equivalent to <paramref name="path"/> which contains <c>%exe%</c> (expanded) as a prefix</returns>
            <remarks>
            returned string omits trailing slash<br/>
            note that the returned string is an absolute path and not a relative path; but TODO it was intended to be relative
            </remarks>
        </member>
        <member name="M:BizHawk.Common.PathExtensions.PathExtensions.MakeRelativeTo(System.String,System.String)">
            <returns>the relative path which is equivalent to <paramref name="absolutePath"/> when the CWD is <paramref name="basePath"/>, or <see langword="null"/> if either path is <see langword="null"/></returns>
            <remarks>
            only returns a relative path if <paramref name="absolutePath"/> is a child of <paramref name="basePath"/> (uses <see cref="M:BizHawk.Common.PathExtensions.PathExtensions.IsSubfolderOf(System.String,System.String)"/>), otherwise returns <paramref name="absolutePath"/><br/>
            returned string omits trailing slash
            </remarks>
        </member>
        <member name="M:BizHawk.Common.PathExtensions.PathExtensions.PathIsSet(System.String)">
            <returns><see langword="false"/> iff <paramref name="path"/> is blank, or is <c>"."</c> (relative path to CWD), regardless of trailing slash</returns>
        </member>
        <member name="F:BizHawk.Common.PathExtensions.PathUtils.DataDirectoryPath">
            <returns>absolute path of the user data dir <c>$BIZHAWK_DATA_HOME</c>, or fallback value equal to <see cref="F:BizHawk.Common.PathExtensions.PathUtils.ExeDirectoryPath"/></returns>
            <remarks>
            returned string omits trailing slash<br/>
            on Windows, the env. var is ignored and the fallback of <see cref="F:BizHawk.Common.PathExtensions.PathUtils.ExeDirectoryPath"/> is always used
            </remarks>
        </member>
        <member name="F:BizHawk.Common.PathExtensions.PathUtils.DllDirectoryPath">
            <returns>absolute path of the dll dir (sibling of EmuHawk.exe)</returns>
            <remarks>returned string omits trailing slash</remarks>
        </member>
        <member name="F:BizHawk.Common.PathExtensions.PathUtils.ExeDirectoryPath">
            <returns>absolute path of the parent dir of DiscoHawk.exe/EmuHawk.exe, commonly referred to as <c>%exe%</c> though none of our code adds it to the environment</returns>
            <remarks>returned string omits trailing slash</remarks>
        </member>
        <member name="T:BizHawk.Common.PathExtensions.PathInternal">
            <summary>Contains internal path helpers that are shared between many projects.</summary>
            <summary>Contains internal path helpers that are shared between many projects.</summary>
        </member>
        <member name="M:BizHawk.Common.PathExtensions.PathInternal.IsValidDriveChar(System.Char)">
            <summary>
            Returns true if the given character is a valid drive letter
            </summary>
        </member>
        <member name="M:BizHawk.Common.PathExtensions.PathInternal.EnsureExtendedPrefixIfNeeded(System.String)">
            <summary>
            Adds the extended path prefix (\\?\) if not already a device path, IF the path is not relative,
            AND the path is more than 259 characters. (> MAX_PATH + null). This will also insert the extended
            prefix if the path ends with a period or a space. Trailing periods and spaces are normally eaten
            away from paths during normalization, but if we see such a path at this point it should be
            normalized and has retained the final characters. (Typically from one of the *Info classes)
            </summary>
        </member>
        <member name="M:BizHawk.Common.PathExtensions.PathInternal.EnsureExtendedPrefix(System.String)">
            <summary>
            Adds the extended path prefix (\\?\) if not relative or already a device path.
            </summary>
        </member>
        <member name="M:BizHawk.Common.PathExtensions.PathInternal.IsDevice(System.String)">
            <summary>
            Returns true if the path uses any of the DOS device path syntaxes. ("\\.\", "\\?\", or "\??\")
            </summary>
        </member>
        <member name="M:BizHawk.Common.PathExtensions.PathInternal.IsExtended(System.String)">
            <summary>
            Returns true if the path uses the canonical form of extended syntax ("\\?\" or "\??\"). If the
            path matches exactly (cannot use alternate directory separators) Windows will skip normalization
            and path length checks.
            </summary>
        </member>
        <member name="T:BizHawk.Common.ReflectionExtensions.ReflectionExtensions">
            <summary>
            Reflection based helper methods
            </summary>
        </member>
        <member name="F:BizHawk.Common.ReflectionExtensions.ReflectionExtensions.DI_TARGET_PROPS">
            <summary>filter used when looking for <c>[RequiredApi]</c> et al. by reflection for dependency injection</summary>
        </member>
        <member name="M:BizHawk.Common.ReflectionExtensions.ReflectionExtensions.GetDescription(System.Object)">
            <summary>
            Gets the description attribute from an object
            </summary>
        </member>
        <member name="M:BizHawk.Common.ReflectionExtensions.ReflectionExtensions.DisplayName(System.Type)">
            <summary>
            Returns the DisplayName attribute value if it exists, else the name of the class
            </summary>
        </member>
        <member name="M:BizHawk.Common.ReflectionExtensions.ReflectionExtensions.GetEnumFromDescription``1(System.String)">
            <summary>
            Gets an enum from a description attribute
            </summary>
            <param name="description">The description attribute value</param>
            <typeparam name="T">The type of the enum</typeparam>
            <returns>An enum value with the given description attribute, if no suitable description is found then a default value of the enum is returned</returns>
            <remarks>implementation from https://stackoverflow.com/a/4367868/7467292</remarks>
        </member>
        <member name="M:BizHawk.Common.ReflectionExtensions.ReflectionExtensions.GetEnumDescriptions(System.Type)">
            <summary>
            Takes an enum Type and generates a list of strings from the description attributes
            </summary>
        </member>
        <member name="M:BizHawk.Common.FFmpegService.QueryServiceAvailable">
            <summary>
            queries whether this service is available. if ffmpeg is broken or missing, then you can handle it gracefully
            </summary>
        </member>
        <member name="M:BizHawk.Common.FFmpegService.DecodeAudio(System.String)">
            <exception cref="T:System.InvalidOperationException">FFmpeg exited with non-zero exit code or produced no output</exception>
        </member>
        <member name="T:BizHawk.Common.HawkArchiveFileItem">
            <summary>Used by <see cref="T:BizHawk.Common.IHawkArchiveFile"/> to represent archive members.</summary>
        </member>
        <member name="F:BizHawk.Common.HawkArchiveFileItem.ArchiveIndex">
            <value>the index of the member within the archive, not to be confused with <see cref="F:BizHawk.Common.HawkArchiveFileItem.Index"/></value>
            <remarks>this is for <see cref="T:BizHawk.Common.IFileDearchivalMethod`1"/> implementations to use internally</remarks>
        </member>
        <member name="F:BizHawk.Common.HawkArchiveFileItem.Index">
            <value>the index of this archive item</value>
        </member>
        <member name="F:BizHawk.Common.HawkArchiveFileItem.Name">
            <value>the member name</value>
        </member>
        <member name="F:BizHawk.Common.HawkArchiveFileItem.Size">
            <value>the size of member file</value>
        </member>
        <member name="T:BizHawk.Common.HawkFile">
            <summary>
            This class can represent a variety of file-like objects—"regular" files on disk, archive members, SMB shares(?)—encapsulating them so any may be opened/read/closed like files on disk.<br/>
            When opening an archive, it won't always be clear automatically which member should actually be used.
            Therefore, we define the concept of "binding": the <see cref="T:BizHawk.Common.HawkFile"/> attaches itself to an archive member, which is the file that it will actually be using.<br/>
            We also define a simple extension to the Unix path format using <c>'|'</c>: <c>/path/to/file.rom</c> is readable, but so is <c>/path/to/archive.zip|member.rom</c>.
            Strings formatted this way are annotated <see cref="T:BizHawk.Common.HawkFilePathAttribute">[HawkFilePath]</see>.
            </summary>
            <remarks>
            This class is defensively designed around <see cref="T:BizHawk.Common.IFileDearchivalMethod`1"/> to allow swapping out implementations (for speed) without adding any dependencies to this project.<br/>
            TODO split into "bind" and "open &lt;the bound thing>"<br/>
            TODO scan archive to flatten interior directories down to a path (maintain our own archive item list)
            </remarks>
        </member>
        <member name="P:BizHawk.Common.HawkFile.ArchiveItems">
            <exception cref="T:System.InvalidOperationException"><see cref="F:BizHawk.Common.HawkFile.IsArchive"/> is <see langword="false"/></exception>
        </member>
        <member name="P:BizHawk.Common.HawkFile.ArchiveMemberPath">
            <value>the member path part of the bound file</value>
        </member>
        <member name="P:BizHawk.Common.HawkFile.CanonicalFullPath">
            <summary>returns the complete canonical full path ("c:\path\to\archive|member") of the bound file</summary>
        </member>
        <member name="P:BizHawk.Common.HawkFile.CanonicalName">
            <summary>returns the complete canonical name ("archive|member") of the bound file</summary>
        </member>
        <member name="P:BizHawk.Common.HawkFile.Directory">
            <summary>Gets the directory containing the root</summary>
        </member>
        <member name="F:BizHawk.Common.HawkFile.Exists">
            <value>true if a file is bound and the bound file exists</value>
        </member>
        <member name="P:BizHawk.Common.HawkFile.Extension">
            <value>the file extension (of <see cref="P:BizHawk.Common.HawkFile.Name"/>); including the leading period and in lowercase</value>
        </member>
        <member name="F:BizHawk.Common.HawkFile.FullPathWithoutMember">
            <value>returns the complete full path of the bound file, excluding the archive member portion</value>
        </member>
        <member name="P:BizHawk.Common.HawkFile.IsArchiveMember">
            <summary>Indicates whether the file is an archive member (IsArchive &amp;&amp; IsBound[to member])</summary>
        </member>
        <member name="P:BizHawk.Common.HawkFile.IsBound">
            <summary>Gets a value indicating whether this instance is bound</summary>
        </member>
        <member name="P:BizHawk.Common.HawkFile.Name">
            <summary>returns the virtual name of the bound file (disregarding the archive). Useful as a basic content identifier.</summary>
        </member>
        <member name="M:BizHawk.Common.HawkFile.#ctor(System.String,System.Boolean,System.Boolean)">
            <summary>Makes a new HawkFile based on the provided path.</summary>
            <param name="delayIOAndDearchive">Pass <see langword="true"/> to only populate a few fields (those that can be computed from the string <paramref name="path"/>), which is less computationally expensive.</param>
        </member>
        <member name="M:BizHawk.Common.HawkFile.BindArchiveMember(BizHawk.Common.HawkArchiveFileItem)">
            <summary>binds the specified ArchiveItem which you should have gotten by interrogating an archive hawkfile</summary>
        </member>
        <member name="M:BizHawk.Common.HawkFile.BindArchiveMember(System.Int32)">
            <summary>binds the selected archive index</summary>
            <exception cref="T:System.InvalidOperationException">stream already bound</exception>
        </member>
        <member name="M:BizHawk.Common.HawkFile.BindArchiveMember(System.String)">
            <summary>binds a path within the archive; returns null if that path didnt exist.</summary>
        </member>
        <member name="M:BizHawk.Common.HawkFile.BindByExtensionCore(System.Collections.Generic.IReadOnlyCollection{System.String},System.Boolean)">
            <param name="extensions">File extensions; include the leading period in each, and use lowercase.</param>
            <exception cref="T:System.InvalidOperationException">stream already bound</exception>
        </member>
        <member name="M:BizHawk.Common.HawkFile.BindFirst">
            <summary>Binds the first archive member if one exists, or for non-archives, binds the file.</summary>
        </member>
        <member name="M:BizHawk.Common.HawkFile.BindFirstOf(System.Collections.Generic.IReadOnlyCollection{System.String})">
            <summary>
            Binds the first archive member whose file extension is in <paramref name="extensions"/> if one exists,
            or for non-archives, binds the file if its file extension is in <paramref name="extensions"/>.
            </summary>
            <param name="extensions">File extensions; include the leading period in each, and use lowercase.</param>
            <remarks>You probably should use <see cref="M:BizHawk.Common.HawkFile.BindSoleItemOf(System.Collections.Generic.IReadOnlyCollection{System.String})"/> or the archive chooser instead.</remarks>
        </member>
        <member name="M:BizHawk.Common.HawkFile.BindFirstOf(System.String)">
            <summary>
            Binds the first archive member whose file extension is <paramref name="extension"/> if one exists,
            or for non-archives, binds the file if its file extension is <paramref name="extension"/>.
            </summary>
            <param name="extension">File extension; include the leading period, and use lowercase.</param>
            <remarks>You probably should use <see cref="M:BizHawk.Common.HawkFile.BindSoleItemOf(System.Collections.Generic.IReadOnlyCollection{System.String})"/> or the archive chooser instead.</remarks>
        </member>
        <member name="M:BizHawk.Common.HawkFile.BindRoot">
            <summary>causes the root to be bound (in the case of non-archive files)</summary>
        </member>
        <member name="M:BizHawk.Common.HawkFile.BindSoleItemOf(System.Collections.Generic.IReadOnlyCollection{System.String})">
            <summary>As <see cref="M:BizHawk.Common.HawkFile.BindFirstOf(System.Collections.Generic.IReadOnlyCollection{System.String})"/>, but doesn't bind anything if there are multiple archive members with a matching file extension.</summary>
            <param name="extensions">File extensions; include the leading period in each, and use lowercase.</param>
        </member>
        <member name="M:BizHawk.Common.HawkFile.FindArchiveMember(System.String)">
            <summary>finds an ArchiveItem with the specified name (path) within the archive; returns null if it doesnt exist</summary>
        </member>
        <member name="M:BizHawk.Common.HawkFile.GetStream">
            <returns>a stream for the currently bound file</returns>
            <exception cref="T:System.InvalidOperationException">no stream bound (haven't called <see cref="M:BizHawk.Common.HawkFile.BindArchiveMember(System.Int32)"/> or overload)</exception>
        </member>
        <member name="M:BizHawk.Common.HawkFile.ReadAllBytes">
            <summary>attempts to read all the content from the file</summary>
        </member>
        <member name="M:BizHawk.Common.HawkFile.Unbind">
            <summary>Removes any existing binding</summary>
        </member>
        <member name="P:BizHawk.Common.HawkFile.DearchivalMethod">
            <summary>Set this with an instance which can construct archive handlers as necessary for archive handling.</summary>
        </member>
        <member name="M:BizHawk.Common.HawkFile.SplitArchiveMemberPath(System.String)">
            <returns>path / member path pair iff <paramref name="path"/> contains <c>'|'</c>, <see langword="null"/> otherwise</returns>
        </member>
        <member name="T:BizHawk.Common.HawkFilePathAttribute">
            <summary>Indicates that a string value is formatted as a path, with an extension to the format: paths followed by <c>'|'</c> and then a relative path represent a member of an archive file.</summary>
            <remarks>
            The archive's path may be absolute or relative. If the path doesn't specify a member (it's a regular path), it obviously may also be absolute or relative.<br/>
            The last '|' is the separator if multiple appear in the path, but the behaviour of such paths generally is undefined. Warnings may be printed on Debug builds.<br/>
            Paths are still OS-dependent. <c>C:\path\to\file</c> and <c>C:\path\to\archive|member</c> are valid on Windows, <c>/path/to/file</c> and <c>/path/to/archive|member</c> are valid everywhere else.<br/>
            This attribute is for humans.<br/>
            TODO how are local (<c>\\?\C:\file.txt</c>) and remote (<c>\\?\UNC\Server\Share\file.txt</c>) UNCs treated by WinForms, and are we able to handle at least the valid ones? --yoshi
            </remarks>
        </member>
        <member name="T:BizHawk.Common.IFileDearchivalMethod`1">
            <summary>Used by <see cref="T:BizHawk.Common.HawkFile"/> to delegate archive management.</summary>
        </member>
        <member name="M:BizHawk.Common.IFileDearchivalMethod`1.CheckSignature(System.String,System.Int32@,System.Boolean@)">
            <remarks>TODO could this receive a <see cref="T:BizHawk.Common.HawkFile"/> itself? possibly handy, in very clever scenarios of mounting fake files</remarks>
        </member>
        <member name="M:BizHawk.Common.IFileDearchivalMethod`1.CheckSignature(System.IO.Stream,System.String)">
            <remarks>for now, only used in tests</remarks>
        </member>
        <member name="M:BizHawk.Common.IFileDearchivalMethod`1.Construct(System.IO.Stream)">
            <remarks>for now, only used in tests</remarks>
        </member>
        <member name="T:BizHawk.Common.IHawkArchiveFile">
            <seealso cref="T:BizHawk.Common.IFileDearchivalMethod`1"/>
        </member>
        <member name="M:BizHawk.Common.IHawkArchiveFile.Scan">
            <returns><see langword="null"/> on failure</returns>
        </member>
        <member name="T:BizHawk.Common.IImportResolver">
            <summary>Implementors are able to provide pointers to functions in dynamically-linked libraries, which are loaded through some undefined mechanism.</summary>
        </member>
        <member name="M:BizHawk.Common.IImportResolver.GetProcAddrOrThrow(System.String)">
            <exception cref="T:System.InvalidOperationException">could not find symbol</exception>
        </member>
        <member name="M:BizHawk.Common.DynamicLibraryImportResolver.#ctor(System.String,System.Boolean)">
            <param name="hasLimitedLifetime">will never be unloaded iff false (like <see cref="T:System.Runtime.InteropServices.DllImportAttribute">[DllImport]</see>)</param>
        </member>
        <member name="T:BizHawk.Common.LinuxDlfcnImports">
            <summary>
            Imports of functions in dlfcn.h
            For Linux, these come from libdl historically
            (Although since glibc 2.34 these are just in libc, with libdl just calling into libc)
            </summary>
        </member>
        <member name="T:BizHawk.Common.IMemoryBlockPal">
            <summary>
            Platform abstraction layer over mmap like functionality
            </summary>
        </member>
        <member name="M:BizHawk.Common.IMemoryBlockPal.Protect(System.UInt64,System.UInt64,BizHawk.Common.MemoryBlock.Protection)">
            <summary>
            Change protection on [start, start + size), guaranteed to be page aligned and in the allocated area
            </summary>
        </member>
        <member name="M:BizHawk.Common.MemoryBlock.#ctor(System.UInt64)">
            <summary>allocate <paramref name="size"/> bytes</summary>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="size"/> is not aligned or is <c>0</c></exception>
        </member>
        <member name="F:BizHawk.Common.MemoryBlock.EndExclusive">
            <summary>
            end address of the memory block (not part of the block; class invariant: equal to <see cref="F:BizHawk.Common.MemoryBlock.Start"/> + <see cref="F:BizHawk.Common.MemoryBlock.Size"/>)
            </summary>
        </member>
        <member name="F:BizHawk.Common.MemoryBlock.Size">
            <summary>total size of the memory block</summary>
        </member>
        <member name="F:BizHawk.Common.MemoryBlock.Start">
            <summary>starting address of the memory block</summary>
        </member>
        <member name="M:BizHawk.Common.MemoryBlock.GetStream(System.UInt64,System.UInt64,System.Boolean)">
            <summary>
            Get a stream that can be used to read or write from part of the block. Does not check for or change <see cref="M:BizHawk.Common.MemoryBlock.Protect(System.UInt64,System.UInt64,BizHawk.Common.MemoryBlock.Protection)"/>!
            </summary>
            <exception cref="T:System.ArgumentOutOfRangeException">
            <paramref name="start"/> or end (= <paramref name="start"/> + <paramref name="length"/> - <c>1</c>)
            are outside [<see cref="F:BizHawk.Common.MemoryBlock.Start"/>, <see cref="F:BizHawk.Common.MemoryBlock.EndExclusive"/>), the range of the block
            </exception>
            <exception cref="T:System.ObjectDisposedException">disposed</exception>
        </member>
        <member name="T:BizHawk.Common.MemoryBlock.Protection">
            <summary>Memory protection constant</summary>
        </member>
        <member name="M:BizHawk.Common.MemoryBlock.Protect(System.UInt64,System.UInt64,BizHawk.Common.MemoryBlock.Protection)">
            <summary>set r/w/x protection on a portion of memory. rounded to encompassing pages</summary>
            <exception cref="T:System.InvalidOperationException">failed to protect memory</exception>
            <exception cref="T:System.ObjectDisposedException">disposed</exception>
        </member>
        <member name="M:BizHawk.Common.MemoryBlockLinuxPal.#ctor(System.UInt64)">
            <summary>
            Map some bytes
            </summary>
            <exception cref="T:System.InvalidOperationException">
            failed to mmap
            </exception>
        </member>
        <member name="M:BizHawk.Common.MemoryBlockUtils.CopySome(System.IO.Stream,System.IO.Stream,System.Int64)">
            <summary>
            copy `len` bytes from `src` to `dest`
            </summary>
        </member>
        <member name="F:BizHawk.Common.MemoryBlockUtils.PageSize">
            <summary>
            System page size, currently hardcoded/assumed to be 4096
            </summary>
        </member>
        <member name="F:BizHawk.Common.MemoryBlockUtils.PageShift">
            <summary>
            bitshift corresponding to PageSize
            </summary>
        </member>
        <member name="F:BizHawk.Common.MemoryBlockUtils.PageMask">
            <summary>
            bitmask corresponding to PageSize
            </summary>
        </member>
        <member name="M:BizHawk.Common.MemoryBlockUtils.Aligned(System.UInt64)">
            <summary>
            true if addr is aligned
            </summary>
        </member>
        <member name="M:BizHawk.Common.MemoryBlockUtils.AlignDown(System.UInt64)">
            <summary>
            align address down to previous page boundary
            </summary>
        </member>
        <member name="M:BizHawk.Common.MemoryBlockUtils.AlignUp(System.UInt64)">
            <summary>
            align address up to next page boundary
            </summary>
        </member>
        <member name="M:BizHawk.Common.MemoryBlockUtils.PagesNeeded(System.UInt64)">
            <summary>
            return the minimum number of pages needed to hold size
            </summary>
        </member>
        <member name="T:BizHawk.Common.MemoryViewStream">
            <summary>
            Create a stream that allows read/write over a set of unmanaged memory pointers
            The validity and lifetime of those pointers is YOUR responsibility
            </summary>
        </member>
        <member name="T:BizHawk.Common.RigidMultiPredicateSort`1">
            <summary>Sorts using a single primary predicate, with subsorts using the remaining predicates in order.</summary>
        </member>
        <member name="M:BizHawk.Common.RigidMultiPredicateSort`1.AppliedTo(System.Collections.Generic.IReadOnlyCollection{`0},System.String,System.Boolean)">
            <remarks>sorts using <paramref name="idOfFirst"/> asc/desc (by <paramref name="firstIsDesc"/>), then by the remaining predicates, all asc</remarks>
        </member>
        <member name="T:BizHawk.Common.OSTailoredCode.ILinkedLibManager">
            <remarks>this interface's inheritors hide OS-specific implementation details</remarks>
        </member>
        <member name="M:BizHawk.Common.OSTailoredCode.ILinkedLibManager.GetProcAddrOrThrow(System.IntPtr,System.String)">
            <exception cref="T:System.InvalidOperationException">could not find symbol</exception>
        </member>
        <member name="M:BizHawk.Common.OSTailoredCode.ILinkedLibManager.LoadOrThrow(System.String)">
            <exception cref="T:System.InvalidOperationException">could not find library</exception>
        </member>
        <member name="M:BizHawk.Common.OSTailoredCode.ConstructSubshell(System.String,System.String,System.Boolean,System.Boolean)">
            <param name="cmd">POSIX <c>$0</c></param>
            <param name="args">POSIX <c>$*</c> (space-delimited)</param>
            <param name="checkStdout">stdout is discarded if false</param>
            <param name="checkStderr">stderr is discarded if false</param>
            <remarks>OS is implicit and needs to be checked at callsite. Returned <see cref="T:System.Diagnostics.Process"/> has not been started.</remarks>
        </member>
        <member name="M:BizHawk.Common.OSTailoredCode.SimpleSubshell(System.String,System.String,System.String)">
            <param name="cmd">POSIX <c>$0</c></param>
            <param name="args">POSIX <c>$*</c> (space-delimited)</param>
            <param name="noOutputMsg">used in exception</param>
            <returns>first line of stdout</returns>
            <exception cref="T:System.Exception">stdout is empty</exception>
            <remarks>OS is implicit and needs to be checked at callsite</remarks>
        </member>
        <member name="T:BizHawk.Common.PosixDlfcnImports">
            <summary>
            Imports of functions in dlfcn.h
            For most POSIX systems, these come from libc
            Linux is a partial exception, as they weren't in libc until glibc 2.34
            (For reference, Debian 10, the current Debian oldoldstable, is on glibc 2.28)
            </summary>
        </member>
        <member name="T:BizHawk.Common.ConstrainedFloatConverter">
            <summary>
            Used in conjunction with the <see cref="T:System.ComponentModel.DataAnnotations.RangeAttribute" /> will perform range validation against a float value using PropertyGrid
            </summary>
        </member>
        <member name="T:BizHawk.Common.ConstrainedIntConverter">
            <summary>
            Used in conjunction with the <see cref="T:System.ComponentModel.DataAnnotations.RangeAttribute" /> will perform range validation against an int value using PropertyGrid
            </summary>
        </member>
        <member name="T:BizHawk.Common.ConstrainedStringConverter">
            <summary>
            Used in conjunction with the <see cref="T:System.ComponentModel.DataAnnotations.MaxLengthAttribute" /> will perform max length validation against a string value using PropertyGrid
            </summary>
        </member>
        <member name="M:BizHawk.Common.Mershul.PtrToStringUtf8(System.IntPtr)">
            <remarks>
            TODO: Update to a version of .nyet that includes this
            </remarks>
        </member>
        <member name="T:BizHawk.Common.Range`1">
            <summary>represents a closed range of <typeparamref name="T"/> (class invariant: <see cref="P:BizHawk.Common.Range`1.Start"/> ≤ <see cref="P:BizHawk.Common.Range`1.EndInclusive"/>)</summary>
        </member>
        <member name="T:BizHawk.Common.MutableRange`1">
            <summary>represents a closed range of <typeparamref name="T"/> which can be grown or shrunk (class invariant: <see cref="P:BizHawk.Common.MutableRange`1.Start"/> ≤ <see cref="P:BizHawk.Common.MutableRange`1.EndInclusive"/>)</summary>
        </member>
        <member name="M:BizHawk.Common.MutableRange`1.#ctor(`0,`0)">
            <inheritdoc cref="M:BizHawk.Common.MutableRange`1.Overwrite(`0,`0)"/>
        </member>
        <member name="P:BizHawk.Common.MutableRange`1.Start">
            <exception cref="T:System.ArgumentOutOfRangeException">(from setter) <paramref name="value"/> > <see cref="P:BizHawk.Common.MutableRange`1.EndInclusive"/></exception>
        </member>
        <member name="P:BizHawk.Common.MutableRange`1.EndInclusive">
            <exception cref="T:System.ArgumentOutOfRangeException">(from setter) <paramref name="value"/> &lt; <see cref="P:BizHawk.Common.MutableRange`1.Start"/></exception>
        </member>
        <member name="M:BizHawk.Common.MutableRange`1.Overwrite(`0,`0)">
            <exception cref="T:System.ArgumentException"><typeparamref name="T"/> is <see langword="float"/>/<see langword="double"/> and either bound is <see cref="F:System.Single.NaN"/></exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="endInclusive"/> &lt; <paramref name="start"/></exception>
        </member>
        <member name="T:BizHawk.Common.RangeExtensions">
            <summary>contains most of the logic for ranges</summary>
            <remarks>
            non-generic overloads are used where the method requires an increment or decrement<br/>
            TODO which Enumerate algorithm is faster - <c>yield return</c> in loop or <see cref="M:System.Linq.Enumerable.Range(System.Int32,System.Int32)"/>?
            </remarks>
        </member>
        <member name="M:BizHawk.Common.RangeExtensions.ConstrainWithin``1(``0,BizHawk.Common.Range{``0})">
            <returns><paramref name="value"/> if it's contained in <paramref name="range"/>, or else whichever bound of <paramref name="range"/> is closest to <paramref name="value"/></returns>
        </member>
        <member name="M:BizHawk.Common.RangeExtensions.Contains``1(BizHawk.Common.Range{``0},``0)">
            <returns>true iff <paramref name="value"/> is contained in <paramref name="range"/> (<paramref name="value"/> is considered to be in the range if it's exactly equal to either bound)</returns>
        </member>
        <member name="M:BizHawk.Common.RangeExtensions.Count(BizHawk.Common.Range{System.Int32})">
            <remarks>beware integer overflow when <paramref name="range"/> contains every value</remarks>
        </member>
        <member name="M:BizHawk.Common.RangeExtensions.Count(BizHawk.Common.Range{System.Int64})">
            <inheritdoc cref="M:BizHawk.Common.RangeExtensions.Count(BizHawk.Common.Range{System.Int32})"/>
        </member>
        <member name="M:BizHawk.Common.RangeExtensions.Count(BizHawk.Common.Range{System.UInt32})">
            <inheritdoc cref="M:BizHawk.Common.RangeExtensions.Count(BizHawk.Common.Range{System.Int32})"/>
        </member>
        <member name="M:BizHawk.Common.RangeExtensions.Count(BizHawk.Common.Range{System.UInt64})">
            <inheritdoc cref="M:BizHawk.Common.RangeExtensions.Count(BizHawk.Common.Range{System.Int32})"/>
        </member>
        <member name="M:BizHawk.Common.RangeExtensions.Enumerate(BizHawk.Common.Range{System.Double},System.Double)">
            <inheritdoc cref="M:BizHawk.Common.RangeExtensions.Enumerate(BizHawk.Common.Range{System.Single},System.Single)"/>
        </member>
        <member name="M:BizHawk.Common.RangeExtensions.Enumerate(BizHawk.Common.Range{System.Single},System.Single)">
            <remarks>beware precision errors</remarks>
        </member>
        <member name="M:BizHawk.Common.RangeExtensions.MutableRangeTo``1(``0,``0)">
            <inheritdoc cref="M:BizHawk.Common.MutableRange`1.#ctor(`0,`0)"/>
        </member>
        <member name="M:BizHawk.Common.RangeExtensions.MutableRangeToExclusive(System.Byte,System.Byte)">
            <inheritdoc cref="M:BizHawk.Common.RangeExtensions.RangeToExclusive(System.Int32,System.Int32)"/>
        </member>
        <member name="M:BizHawk.Common.RangeExtensions.MutableRangeToExclusive(System.Int32,System.Int32)">
            <inheritdoc cref="M:BizHawk.Common.RangeExtensions.RangeToExclusive(System.Int32,System.Int32)"/>
        </member>
        <member name="M:BizHawk.Common.RangeExtensions.MutableRangeToExclusive(System.Int64,System.Int64)">
            <inheritdoc cref="M:BizHawk.Common.RangeExtensions.RangeToExclusive(System.Int32,System.Int32)"/>
        </member>
        <member name="M:BizHawk.Common.RangeExtensions.MutableRangeToExclusive(System.SByte,System.SByte)">
            <inheritdoc cref="M:BizHawk.Common.RangeExtensions.RangeToExclusive(System.Int32,System.Int32)"/>
        </member>
        <member name="M:BizHawk.Common.RangeExtensions.MutableRangeToExclusive(System.Int16,System.Int16)">
            <inheritdoc cref="M:BizHawk.Common.RangeExtensions.RangeToExclusive(System.Int32,System.Int32)"/>
        </member>
        <member name="M:BizHawk.Common.RangeExtensions.MutableRangeToExclusive(System.UInt32,System.UInt32)">
            <inheritdoc cref="M:BizHawk.Common.RangeExtensions.RangeToExclusive(System.Int32,System.Int32)"/>
        </member>
        <member name="M:BizHawk.Common.RangeExtensions.MutableRangeToExclusive(System.UInt64,System.UInt64)">
            <inheritdoc cref="M:BizHawk.Common.RangeExtensions.RangeToExclusive(System.Int32,System.Int32)"/>
        </member>
        <member name="M:BizHawk.Common.RangeExtensions.MutableRangeToExclusive(System.UInt16,System.UInt16)">
            <inheritdoc cref="M:BizHawk.Common.RangeExtensions.RangeToExclusive(System.Int32,System.Int32)"/>
        </member>
        <member name="M:BizHawk.Common.RangeExtensions.RangeTo``1(``0,``0)">
            <inheritdoc cref="M:BizHawk.Common.MutableRange`1.#ctor(`0,`0)"/>
        </member>
        <member name="M:BizHawk.Common.RangeExtensions.RangeToExclusive(System.Byte,System.Byte)">
            <inheritdoc cref="M:BizHawk.Common.RangeExtensions.RangeToExclusive(System.Int32,System.Int32)"/>
        </member>
        <member name="M:BizHawk.Common.RangeExtensions.RangeToExclusive(System.Int32,System.Int32)">
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="endExclusive"/> ≤ <paramref name="start"/> (empty ranges where <paramref name="start"/> = <paramref name="endExclusive"/> are not permitted)</exception>
            <exception cref="T:System.ArithmeticException"><paramref name="endExclusive"/> is min value of integral type (therefore <paramref name="endExclusive"/> ≤ <paramref name="start"/>)</exception>
        </member>
        <member name="M:BizHawk.Common.RangeExtensions.RangeToExclusive(System.Int64,System.Int64)">
            <inheritdoc cref="M:BizHawk.Common.RangeExtensions.RangeToExclusive(System.Int32,System.Int32)"/>
        </member>
        <member name="M:BizHawk.Common.RangeExtensions.RangeToExclusive(System.SByte,System.SByte)">
            <inheritdoc cref="M:BizHawk.Common.RangeExtensions.RangeToExclusive(System.Int32,System.Int32)"/>
        </member>
        <member name="M:BizHawk.Common.RangeExtensions.RangeToExclusive(System.Int16,System.Int16)">
            <inheritdoc cref="M:BizHawk.Common.RangeExtensions.RangeToExclusive(System.Int32,System.Int32)"/>
        </member>
        <member name="M:BizHawk.Common.RangeExtensions.RangeToExclusive(System.UInt32,System.UInt32)">
            <inheritdoc cref="M:BizHawk.Common.RangeExtensions.RangeToExclusive(System.Int32,System.Int32)"/>
        </member>
        <member name="M:BizHawk.Common.RangeExtensions.RangeToExclusive(System.UInt64,System.UInt64)">
            <inheritdoc cref="M:BizHawk.Common.RangeExtensions.RangeToExclusive(System.Int32,System.Int32)"/>
        </member>
        <member name="M:BizHawk.Common.RangeExtensions.RangeToExclusive(System.UInt16,System.UInt16)">
            <inheritdoc cref="M:BizHawk.Common.RangeExtensions.RangeToExclusive(System.Int32,System.Int32)"/>
        </member>
        <member name="M:BizHawk.Common.RangeExtensions.StrictlyBoundedBy``1(``0,BizHawk.Common.Range{``0})">
            <returns>true iff <paramref name="value"/> is strictly contained in <paramref name="range"/> (<paramref name="value"/> is considered to be OUTSIDE the range if it's exactly equal to either bound)</returns>
        </member>
        <member name="M:BizHawk.Common.Serializer.SyncEnum``1(System.String,``0@)">
            <exception cref="T:System.InvalidOperationException"><typeparamref name="T"/> does not inherit <see cref="T:System.Enum"/></exception>
        </member>
        <member name="M:BizHawk.Common.Serializer.SyncFixedString(System.String,System.String@,System.Int32)">
            <exception cref="T:System.InvalidOperationException"><see cref="P:BizHawk.Common.Serializer.IsReader"/> is <see langword="false"/> and <paramref name="name"/> is longer than <paramref name="length"/> chars</exception>
        </member>
        <member name="T:BizHawk.Common.SimpleTime">
            <summary>Create a new instance of this class in a <see langword="using"/> block, and it will measure the time elapsed until the block finishes executing. Provide a label to print to stdout or provide a callback for custom behaviour.</summary>
        </member>
        <member name="T:BizHawk.Common.ISpanStream">
            <summary>
            TODO: Switch to dotnet core and remove this junkus
            </summary>
        </member>
        <member name="M:BizHawk.Common.SpanStream.GetOrBuild(System.IO.Stream)">
            <returns>a stream in spanstream mode, or a newly-created wrapper which provides that functionality</returns>
        </member>
        <member name="T:BizHawk.Common.TempFileManager">
            <summary>
            Starts a thread which cleans any filenames in %temp% beginning with bizhawk.bizdelete.
            Files shouldn't be named that unless they're safe to delete, but notably, they may still be in use. That won't hurt this component.
            When they're no longer in use, this component will then be able to delete them.
            </summary>
        </member>
        <member name="M:BizHawk.Common.TempFileManager.RenameTempFilenameForDelete(System.String)">
            <exception cref="T:System.InvalidOperationException">filename in <paramref name="path"/> is not one generated by <see cref="M:BizHawk.Common.TempFileManager.GetTempFilename(System.String,System.String,System.Boolean)"/></exception>
        </member>
        <member name="F:BizHawk.Common.UndoHistory`1._curPos">
            <remarks>
            <c>1</c>-based, so the "current timeline" includes all of <see cref="F:BizHawk.Common.UndoHistory`1._history"/> up to and not including <c>_history[_curPos]</c>
            (that is, all of <see cref="F:BizHawk.Common.UndoHistory`1._history"/> has been redo'd when <c>_curPos == _history.Count</c>)
            </remarks>
        </member>
        <member name="P:BizHawk.Common.UndoHistory`1.MaxUndoLevels">
            <remarks>
            <see cref="F:BizHawk.Common.UndoHistory`1._history"/> can actually grow to this + 1<br/>
            TODO fix that by moving the <c>.RemoveAt(0)</c> loop in <see cref="M:BizHawk.Common.UndoHistory`1.AddState(`0)"/> to AFTER the insertion<br/>
            TODO old code assumed the setter was public, so pruning multiple states from start may have been required if this changed between insertions
            </remarks>
        </member>
        <member name="M:BizHawk.Common.UndoHistory`1.#ctor(System.Boolean,`0)">
            <param name="blankState">
            returned from calls to <see cref="M:BizHawk.Common.UndoHistory`1.Undo"/>/<see cref="M:BizHawk.Common.UndoHistory`1.Redo"/> when there is nothing to undo/redo, or
            when either method is called while disabled
            </param>
        </member>
        <member name="M:BizHawk.Common.Util.DebugWriteLine">
            <summary>equivalent to <see cref="M:System.Console.WriteLine">Console.WriteLine</see> but is <c>#ifdef DEBUG</c></summary>
        </member>
        <member name="M:BizHawk.Common.Util.DebugWriteLine(System.String)">
            <summary>equivalent to <see cref="M:System.Console.WriteLine(System.String)">Console.WriteLine</see> but is <c>#ifdef DEBUG</c></summary>
        </member>
        <member name="M:BizHawk.Common.Util.DebugWriteLine(System.Object)">
            <summary>equivalent to <see cref="M:System.Console.WriteLine(System.Object)">Console.WriteLine</see> but is <c>#ifdef DEBUG</c></summary>
        </member>
        <member name="M:BizHawk.Common.Util.DebugWriteLine(System.String,System.Object[])">
            <summary>equivalent to <see cref="M:System.Console.WriteLine(System.String,System.Object[])">Console.WriteLine</see> but is <c>#ifdef DEBUG</c></summary>
        </member>
        <member name="M:BizHawk.Common.Util.DecompressGzipFile(System.IO.Stream)">
            <exception cref="T:System.InvalidOperationException">issues with parsing <paramref name="src"/></exception>
            <remarks>TODO use <see cref="M:System.IO.MemoryStream.#ctor(System.Int32)"/> and <see cref="M:System.IO.MemoryStream.ToArray"/> instead of using <see cref="M:System.IO.MemoryStream.#ctor(System.Byte[])"/> and keeping a reference to the array? --yoshi</remarks>
        </member>
        <member name="M:BizHawk.Common.Util.DictionaryEqual``2(System.Collections.Generic.IDictionary{``0,``1},System.Collections.Generic.IDictionary{``0,``1})">
            <remarks>adapted from https://stackoverflow.com/a/3928856/7467292, values are compared using <see cref="P:System.Collections.Generic.EqualityComparer`1.Default">EqualityComparer.Default</see></remarks>
        </member>
        <member name="M:BizHawk.Common.Util.FormatFileSize(System.Int64)">
            <param name="filesize">in bytes</param>
            <returns>human-readable filesize (converts units up to tebibytes)</returns>
        </member>
        <member name="M:BizHawk.Common.Util.GetTypeByName(System.String)">
            <returns>all <see cref="T:System.Type">Types</see> with the name <paramref name="className"/></returns>
            <remarks>adapted from https://stackoverflow.com/a/13727044/7467292</remarks>
        </member>
        <member name="M:BizHawk.Common.Util.GetTypesWithoutLoadErrors(System.Reflection.Assembly)">
            <remarks>TODO replace this with GetTypes (i.e. the try block) when VB.NET dep is properly removed</remarks>
        </member>
        <member name="M:BizHawk.Common.Util.HexStringToBytes(System.String)">
            <exception cref="T:System.ArgumentException"><paramref name="str"/> has an odd number of chars or contains a char not in <c>[0-9A-Fa-f]</c></exception>
        </member>
        <member name="M:BizHawk.Common.Util.ToBoolBuffer(System.Byte[])">
            <remarks>Any non-zero element is interpreted as <see langword="true"/>.</remarks>
        </member>
        <member name="M:BizHawk.Common.Util.ToIntBuffer(System.Byte[])">
            <remarks>Each set of 4 elements in <paramref name="buf"/> becomes 1 element in the returned buffer. The first of each set is interpreted as the LSB, with the 4th being the MSB. Elements are used as raw bits without regard for sign.</remarks>
        </member>
        <member name="M:BizHawk.Common.Util.ToShortBuffer(System.Byte[])">
            <remarks>Each pair of elements in <paramref name="buf"/> becomes 1 element in the returned buffer. The first of each pair is interpreted as the LSB. Elements are used as raw bits without regard for sign.</remarks>
        </member>
        <member name="M:BizHawk.Common.Util.ToUByteBuffer(System.Int32[])">
            <remarks>Each element of <paramref name="buf"/> becomes 4 elements in the returned buffer, with the LSB coming first. Elements are used as raw bits without regard for sign.</remarks>
        </member>
        <member name="M:BizHawk.Common.Util.ToUByteBuffer(System.Int16[])">
            <remarks>Each element of <paramref name="buf"/> becomes 2 elements in the returned buffer, with the LSB coming first. Elements are used as raw bits without regard for sign.</remarks>
        </member>
        <member name="M:BizHawk.Common.Util.ToUByteBuffer(System.UInt32[])">
            <inheritdoc cref="M:BizHawk.Common.Util.ToUByteBuffer(System.Int32[])"/>
        </member>
        <member name="M:BizHawk.Common.Util.ToUByteBuffer(System.UInt16[])">
            <inheritdoc cref="M:BizHawk.Common.Util.ToUByteBuffer(System.Int16[])"/>
        </member>
        <member name="M:BizHawk.Common.Util.ToUIntBuffer(System.Byte[])">
            <inheritdoc cref="M:BizHawk.Common.Util.ToIntBuffer(System.Byte[])"/>
        </member>
        <member name="M:BizHawk.Common.Util.ToUShortBuffer(System.Byte[])">
            <inheritdoc cref="M:BizHawk.Common.Util.ToShortBuffer(System.Byte[])"/>
        </member>
        <member name="M:BizHawk.Common.Util.TryMoveBackupFile(System.String,System.String)">
            <summary>Tries really hard to keep the contents of <paramref name="desiredPath"/> saved (as <paramref name="backupPath"/>) while freeing that path to be used for a new file.</summary>
            <remarks>If both <paramref name="desiredPath"/> and <paramref name="backupPath"/> exist, <paramref name="backupPath"/> is always deleted.</remarks>
        </member>
        <member name="M:BizHawk.Common.Util.UnsafeSpanFromPointer(System.IntPtr,System.Int32)">
            <summary>creates span over <paramref name="length"/> octets starting at <paramref name="ptr"/></summary>
        </member>
        <member name="M:BizHawk.Common.Util.UnsafeSpanFromPointer``1(System.IntPtr,System.Int32)">
            <summary>
            creates span over <paramref name="count"/><c> * sizeof(</c><typeparamref name="T"/><c>)</c> octets
            starting at <paramref name="ptr"/>
            </summary>
            <remarks>uses native endianness</remarks>
        </member>
        <member name="F:BizHawk.Common.VersionInfo.MainVersion">
            <remarks>
            Bump this immediately after release.
            Only use '0'..'9' and '.' or it will fail to parse and the new version notification won't work.
            </remarks>
        </member>
        <member name="M:BizHawk.Common.VersionInfo.VersionStrToInt(System.String)">
            <summary>"2.5.1" => 0x02050100</summary>
        </member>
        <member name="M:BizHawk.Common.AVIWriterImports.AVIFileCreateStreamW(System.IntPtr,System.IntPtr@,BizHawk.Common.AVIWriterImports.AVISTREAMINFOW@)">
            <summary>Create a new stream in an existing file and creates an interface to the new stream</summary>
        </member>
        <member name="M:BizHawk.Common.AVIWriterImports.AVIFileRelease(System.IntPtr)">
            <summary>Release an open AVI stream</summary>
        </member>
        <member name="M:BizHawk.Common.AVIWriterImports.AVIMakeCompressedStream(System.IntPtr@,System.IntPtr,BizHawk.Common.AVIWriterImports.AVICOMPRESSOPTIONS@,System.IntPtr)">
            <summary>Create a compressed stream from an uncompressed stream and a compression filter, and returns the address of a pointer to the compressed stream</summary>
        </member>
        <member name="M:BizHawk.Common.AVIWriterImports.AVISaveOptions(System.IntPtr,System.Int32,System.Int32,System.Void*,System.Void*)">
            <summary>Retrieve the save options for a file and returns them in a buffer</summary>
        </member>
        <member name="M:BizHawk.Common.AVIWriterImports.AVIStreamRelease(System.IntPtr)">
            <inheritdoc cref="M:BizHawk.Common.AVIWriterImports.AVIFileRelease(System.IntPtr)"/>
        </member>
        <member name="M:BizHawk.Common.AVIWriterImports.AVIStreamSetFormat(System.IntPtr,System.Int32,BizHawk.Common.AVIWriterImports.BITMAPINFOHEADER@,System.Int32)">
            <summary>Set the format of a stream at the specified position</summary>
        </member>
        <member name="M:BizHawk.Common.AVIWriterImports.AVIStreamSetFormat(System.IntPtr,System.Int32,BizHawk.Common.AVIWriterImports.WAVEFORMATEX@,System.Int32)">
            <inheritdoc cref="M:BizHawk.Common.AVIWriterImports.AVIStreamSetFormat(System.IntPtr,System.Int32,BizHawk.Common.AVIWriterImports.BITMAPINFOHEADER@,System.Int32)"/>
        </member>
        <member name="M:BizHawk.Common.AVIWriterImports.AVIStreamWrite(System.IntPtr,System.Int32,System.Int32,System.IntPtr,System.Int32,System.Int32,System.IntPtr,System.Int32@)">
            <summary>Write data to a stream</summary>
        </member>
        <member name="T:BizHawk.Common.CWDHacks">
            <summary>Gets/Sets the current working directory while bypassing the security checks triggered by the public API (<see cref="P:System.Environment.CurrentDirectory"/>).</summary>
        </member>
        <member name="M:BizHawk.Common.HeapApiImports.HeapFree(System.IntPtr,System.UInt32,System.IntPtr)">
            <remarks>used in <c>#if false</c> code in <c>AviWriter.CodecToken.DeallocateAVICOMPRESSOPTIONS</c>, don't delete it</remarks>
        </member>
        <member name="T:BizHawk.Common.MotWHack">
            <remarks>This code (and an import for <see cref="M:BizHawk.Common.Win32Imports.DeleteFileW(System.String)"/>) is duplicated in each executable project because it needs to be used before loading assemblies.</remarks>
        </member>
        <member name="T:BizHawk.Common.RawInputImports.RawKey">
            <summary>
            This enum generally assumes a QWERTY layout (and goes off PS/2 Set 1 scancodes, i.e. what RAWINPUT uses)
            Bit7 will indicate that the input has an E0 prefix
            (This also somewhat mimics DirectInput's DIK_ enum)
            </summary>
        </member>
        <member name="F:BizHawk.Common.Shell32Imports.BROWSEINFOW.FLAGS.RestrictToFilesystem">
            <remarks>BIF_RETURNONLYFSDIRS</remarks>
        </member>
        <member name="F:BizHawk.Common.Shell32Imports.BROWSEINFOW.FLAGS.RestrictToDomain">
            <remarks>BIF_DONTGOBELOWDOMAIN</remarks>
        </member>
        <member name="F:BizHawk.Common.Shell32Imports.BROWSEINFOW.FLAGS.RestrictToSubfolders">
            <remarks>BIF_RETURNFSANCESTORS</remarks>
        </member>
        <member name="F:BizHawk.Common.Shell32Imports.BROWSEINFOW.FLAGS.ShowTextBox">
            <remarks>BIF_EDITBOX</remarks>
        </member>
        <member name="F:BizHawk.Common.Shell32Imports.BROWSEINFOW.FLAGS.ValidateSelection">
            <remarks>BIF_VALIDATE</remarks>
        </member>
        <member name="F:BizHawk.Common.Shell32Imports.BROWSEINFOW.FLAGS.NewDialogStyle">
            <remarks>BIF_NEWDIALOGSTYLE</remarks>
        </member>
        <member name="F:BizHawk.Common.Shell32Imports.BROWSEINFOW.FLAGS.BrowseForComputer">
            <remarks>BIF_BROWSEFORCOMPUTER</remarks>
        </member>
        <member name="F:BizHawk.Common.Shell32Imports.BROWSEINFOW.FLAGS.BrowseForPrinter">
            <remarks>BIF_BROWSEFORPRINTER</remarks>
        </member>
        <member name="F:BizHawk.Common.Shell32Imports.BROWSEINFOW.FLAGS.BrowseForEverything">
            <remarks>BIF_BROWSEINCLUDEFILES</remarks>
        </member>
        <member name="T:BizHawk.Common.ShellLinkImports.IShellLinkW">
            <summary>The IShellLink interface allows Shell links to be created, modified, and resolved</summary>
        </member>
        <member name="T:BizHawk.Common.ShellLinkImports.ShellLink">
            <remarks>CLSID_ShellLink from ShlGuid.h</remarks>
        </member>
        <member name="T:BizHawk.Common.ThreadHacks">
            <remarks>
            largely from https://raw.githubusercontent.com/noserati/tpl/master/ThreadAffinityTaskScheduler.cs (MIT license)<br/>
            most of this is used in <c>#if false</c> code in <c>mupen64plusApi.frame_advance()</c>, don't delete it
            </remarks>
        </member>
        <member name="T:BizHawk.Common.Win32Imports">
            <summary>
            This is more just an assorted bunch of Win32 functions
            </summary>
        </member>
        <member name="M:BizHawk.Common.Zstd.CreateZstdCompressionStream(System.IO.Stream,System.Int32)">
            <summary>
            Creates a zstd compression stream.
            This stream uses a shared context as to avoid buffer allocation spam.
            It is absolutely important to call Dispose() / use using on returned stream.
            If this is not done, the shared context will remain in use,
            and the proceeding attempt to initialize it will throw.
            Also, of course, do not attempt to create multiple streams at once.
            Only 1 stream at a time is allowed per Zstd instance.
            </summary>
            <param name="stream">the stream to write compressed data</param>
            <param name="compressionLevel">compression level, bounded by MinCompressionLevel and MaxCompressionLevel</param>
            <returns>zstd compression stream</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">compressionLevel is too small or too big</exception>
        </member>
        <member name="M:BizHawk.Common.Zstd.CreateZstdDecompressionStream(System.IO.Stream)">
            <summary>
            Creates a zstd decompression stream.
            This stream uses a shared context as to avoid buffer allocation spam.
            It is absolutely important to call Dispose() / use using on returned stream.
            If this is not done, the shared context will remain in use,
            and the proceeding attempt to initialize it will throw.
            Also, of course, do not attempt to create multiple streams at once.
            Only 1 stream at a time is allowed per Zstd instance.
            </summary>
            <param name="stream">a stream with zstd compressed data to decompress</param>
            <returns>zstd decompression stream</returns>
        </member>
        <member name="M:BizHawk.Common.Zstd.DecompressZstdStream(System.IO.Stream)">
            <summary>
            Decompresses src stream and returns a memory stream with the decompressed contents.
            Context creation and disposing is handled internally in this function, unlike the non-static ones.
            This is useful in cases where you are not doing repeated decompressions,
            so keeping a Zstd instance around is not as useful.
            </summary>
            <param name="src">stream with zstd compressed data to decompress</param>
            <returns>MemoryStream with the decompressed contents of src</returns>
            <exception cref="T:System.InvalidOperationException">src does not have a ZSTD header</exception>
        </member>
        <member name="M:BizHawk.Common.ReflectionCache.EmbeddedResourceStream(System.String)">
            <exception cref="T:System.ArgumentException">not found</exception>
        </member>
    </members>
</doc>
